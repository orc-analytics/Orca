// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.21.12
// source: vendor/validate.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  FieldDescriptorProto_Type,
  fieldDescriptorProto_TypeFromJSON,
  fieldDescriptorProto_TypeToJSON,
} from "../google/protobuf/descriptor";
import { Duration } from "../google/protobuf/duration";
import { Timestamp } from "../google/protobuf/timestamp";

export const protobufPackage = "buf.validate";

/**
 * Specifies how FieldConstraints.ignore behaves. See the documentation for
 * FieldConstraints.required for definitions of "populated" and "nullable".
 */
export enum Ignore {
  /**
   * IGNORE_UNSPECIFIED - Validation is only skipped if it's an unpopulated nullable fields.
   *
   * ```proto
   * syntax="proto3";
   *
   * message Request {
   *   // The uri rule applies to any value, including the empty string.
   *   string foo = 1 [
   *     (buf.validate.field).string.uri = true
   *   ];
   *
   *   // The uri rule only applies if the field is set, including if it's
   *   // set to the empty string.
   *   optional string bar = 2 [
   *     (buf.validate.field).string.uri = true
   *   ];
   *
   *   // The min_items rule always applies, even if the list is empty.
   *   repeated string baz = 3 [
   *     (buf.validate.field).repeated.min_items = 3
   *   ];
   *
   *   // The custom CEL rule applies only if the field is set, including if
   *   // it's the "zero" value of that message.
   *   SomeMessage quux = 4 [
   *     (buf.validate.field).cel = {/* ... * /}
   *   ];
   * }
   * ```
   */
  IGNORE_UNSPECIFIED = 0,
  /**
   * IGNORE_IF_UNPOPULATED - Validation is skipped if the field is unpopulated. This rule is redundant
   * if the field is already nullable.
   *
   * ```proto
   * syntax="proto3
   *
   * message Request {
   *   // The uri rule applies only if the value is not the empty string.
   *   string foo = 1 [
   *     (buf.validate.field).string.uri = true,
   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
   *   ];
   *
   *   // IGNORE_IF_UNPOPULATED is equivalent to IGNORE_UNSPECIFIED in this
   *   // case: the uri rule only applies if the field is set, including if
   *   // it's set to the empty string.
   *   optional string bar = 2 [
   *     (buf.validate.field).string.uri = true,
   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
   *   ];
   *
   *   // The min_items rule only applies if the list has at least one item.
   *   repeated string baz = 3 [
   *     (buf.validate.field).repeated.min_items = 3,
   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
   *   ];
   *
   *   // IGNORE_IF_UNPOPULATED is equivalent to IGNORE_UNSPECIFIED in this
   *   // case: the custom CEL rule applies only if the field is set, including
   *   // if it's the "zero" value of that message.
   *   SomeMessage quux = 4 [
   *     (buf.validate.field).cel = {/* ... * /},
   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
   *   ];
   * }
   * ```
   */
  IGNORE_IF_UNPOPULATED = 1,
  /**
   * IGNORE_IF_DEFAULT_VALUE - Validation is skipped if the field is unpopulated or if it is a nullable
   * field populated with its default value. This is typically the zero or
   * empty value, but proto2 scalars support custom defaults. For messages, the
   * default is a non-null message with all its fields unpopulated.
   *
   * ```proto
   * syntax="proto3
   *
   * message Request {
   *   // IGNORE_IF_DEFAULT_VALUE is equivalent to IGNORE_IF_UNPOPULATED in
   *   // this case; the uri rule applies only if the value is not the empty
   *   // string.
   *   string foo = 1 [
   *     (buf.validate.field).string.uri = true,
   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE
   *   ];
   *
   *   // The uri rule only applies if the field is set to a value other than
   *   // the empty string.
   *   optional string bar = 2 [
   *     (buf.validate.field).string.uri = true,
   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE
   *   ];
   *
   *   // IGNORE_IF_DEFAULT_VALUE is equivalent to IGNORE_IF_UNPOPULATED in
   *   // this case; the min_items rule only applies if the list has at least
   *   // one item.
   *   repeated string baz = 3 [
   *     (buf.validate.field).repeated.min_items = 3,
   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE
   *   ];
   *
   *   // The custom CEL rule only applies if the field is set to a value other
   *   // than an empty message (i.e., fields are unpopulated).
   *   SomeMessage quux = 4 [
   *     (buf.validate.field).cel = {/* ... * /},
   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE
   *   ];
   * }
   * ```
   *
   * This rule is affected by proto2 custom default values:
   *
   * ```proto
   * syntax="proto2";
   *
   * message Request {
   *   // The gt rule only applies if the field is set and it's value is not
   *   the default (i.e., not -42). The rule even applies if the field is set
   *   to zero since the default value differs.
   *   optional int32 value = 1 [
   *     default = -42,
   *     (buf.validate.field).int32.gt = 0,
   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE
   *   ];
   * }
   */
  IGNORE_IF_DEFAULT_VALUE = 2,
  /**
   * IGNORE_ALWAYS - The validation rules of this field will be skipped and not evaluated. This
   * is useful for situations that necessitate turning off the rules of a field
   * containing a message that may not make sense in the current context, or to
   * temporarily disable constraints during development.
   *
   * ```proto
   * message MyMessage {
   *   // The field's rules will always be ignored, including any validation's
   *   // on value's fields.
   *   MyOtherMessage value = 1 [
   *     (buf.validate.field).ignore = IGNORE_ALWAYS];
   * }
   * ```
   */
  IGNORE_ALWAYS = 3,
  UNRECOGNIZED = -1,
}

export function ignoreFromJSON(object: any): Ignore {
  switch (object) {
    case 0:
    case "IGNORE_UNSPECIFIED":
      return Ignore.IGNORE_UNSPECIFIED;
    case 1:
    case "IGNORE_IF_UNPOPULATED":
      return Ignore.IGNORE_IF_UNPOPULATED;
    case 2:
    case "IGNORE_IF_DEFAULT_VALUE":
      return Ignore.IGNORE_IF_DEFAULT_VALUE;
    case 3:
    case "IGNORE_ALWAYS":
      return Ignore.IGNORE_ALWAYS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Ignore.UNRECOGNIZED;
  }
}

export function ignoreToJSON(object: Ignore): string {
  switch (object) {
    case Ignore.IGNORE_UNSPECIFIED:
      return "IGNORE_UNSPECIFIED";
    case Ignore.IGNORE_IF_UNPOPULATED:
      return "IGNORE_IF_UNPOPULATED";
    case Ignore.IGNORE_IF_DEFAULT_VALUE:
      return "IGNORE_IF_DEFAULT_VALUE";
    case Ignore.IGNORE_ALWAYS:
      return "IGNORE_ALWAYS";
    case Ignore.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** WellKnownRegex contain some well-known patterns. */
export enum KnownRegex {
  KNOWN_REGEX_UNSPECIFIED = 0,
  /** KNOWN_REGEX_HTTP_HEADER_NAME - HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2). */
  KNOWN_REGEX_HTTP_HEADER_NAME = 1,
  /** KNOWN_REGEX_HTTP_HEADER_VALUE - HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4). */
  KNOWN_REGEX_HTTP_HEADER_VALUE = 2,
  UNRECOGNIZED = -1,
}

export function knownRegexFromJSON(object: any): KnownRegex {
  switch (object) {
    case 0:
    case "KNOWN_REGEX_UNSPECIFIED":
      return KnownRegex.KNOWN_REGEX_UNSPECIFIED;
    case 1:
    case "KNOWN_REGEX_HTTP_HEADER_NAME":
      return KnownRegex.KNOWN_REGEX_HTTP_HEADER_NAME;
    case 2:
    case "KNOWN_REGEX_HTTP_HEADER_VALUE":
      return KnownRegex.KNOWN_REGEX_HTTP_HEADER_VALUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KnownRegex.UNRECOGNIZED;
  }
}

export function knownRegexToJSON(object: KnownRegex): string {
  switch (object) {
    case KnownRegex.KNOWN_REGEX_UNSPECIFIED:
      return "KNOWN_REGEX_UNSPECIFIED";
    case KnownRegex.KNOWN_REGEX_HTTP_HEADER_NAME:
      return "KNOWN_REGEX_HTTP_HEADER_NAME";
    case KnownRegex.KNOWN_REGEX_HTTP_HEADER_VALUE:
      return "KNOWN_REGEX_HTTP_HEADER_VALUE";
    case KnownRegex.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * `Constraint` represents a validation rule written in the Common Expression
 * Language (CEL) syntax. Each Constraint includes a unique identifier, an
 * optional error message, and the CEL expression to evaluate. For more
 * information on CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).
 *
 * ```proto
 * message Foo {
 *   option (buf.validate.message).cel = {
 *     id: "foo.bar"
 *     message: "bar must be greater than 0"
 *     expression: "this.bar > 0"
 *   };
 *   int32 bar = 1;
 * }
 * ```
 */
export interface Constraint {
  /**
   * `id` is a string that serves as a machine-readable name for this Constraint.
   * It should be unique within its scope, which could be either a message or a field.
   */
  id?:
    | string
    | undefined;
  /**
   * `message` is an optional field that provides a human-readable error message
   * for this Constraint when the CEL expression evaluates to false. If a
   * non-empty message is provided, any strings resulting from the CEL
   * expression evaluation are ignored.
   */
  message?:
    | string
    | undefined;
  /**
   * `expression` is the actual CEL expression that will be evaluated for
   * validation. This string must resolve to either a boolean or a string
   * value. If the expression evaluates to false or a non-empty string, the
   * validation is considered failed, and the message is rejected.
   */
  expression?: string | undefined;
}

/**
 * MessageConstraints represents validation rules that are applied to the entire message.
 * It includes disabling options and a list of Constraint messages representing Common Expression Language (CEL) validation rules.
 */
export interface MessageConstraints {
  /**
   * `disabled` is a boolean flag that, when set to true, nullifies any validation rules for this message.
   * This includes any fields within the message that would otherwise support validation.
   *
   * ```proto
   * message MyMessage {
   *   // validation will be bypassed for this message
   *   option (buf.validate.message).disabled = true;
   * }
   * ```
   */
  disabled?:
    | boolean
    | undefined;
  /**
   * `cel` is a repeated field of type Constraint. Each Constraint specifies a validation rule to be applied to this message.
   * These constraints are written in Common Expression Language (CEL) syntax. For more information on
   * CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).
   *
   * ```proto
   * message MyMessage {
   *   // The field `foo` must be greater than 42.
   *   option (buf.validate.message).cel = {
   *     id: "my_message.value",
   *     message: "value must be greater than 42",
   *     expression: "this.foo > 42",
   *   };
   *   optional int32 foo = 1;
   * }
   * ```
   */
  cel?: Constraint[] | undefined;
}

/**
 * The `OneofConstraints` message type enables you to manage constraints for
 * oneof fields in your protobuf messages.
 */
export interface OneofConstraints {
  /**
   * If `required` is true, exactly one field of the oneof must be present. A
   * validation error is returned if no fields in the oneof are present. The
   * field itself may still be a default value; further constraints
   * should be placed on the fields themselves to ensure they are valid values,
   * such as `min_len` or `gt`.
   *
   * ```proto
   * message MyMessage {
   *   oneof value {
   *     // Either `a` or `b` must be set. If `a` is set, it must also be
   *     // non-empty; whereas if `b` is set, it can still be an empty string.
   *     option (buf.validate.oneof).required = true;
   *     string a = 1 [(buf.validate.field).string.min_len = 1];
   *     string b = 2;
   *   }
   * }
   * ```
   */
  required?: boolean | undefined;
}

/**
 * FieldConstraints encapsulates the rules for each type of field. Depending on
 * the field, the correct set should be used to ensure proper validations.
 */
export interface FieldConstraints {
  /**
   * `cel` is a repeated field used to represent a textual expression
   * in the Common Expression Language (CEL) syntax. For more information on
   * CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).
   *
   * ```proto
   * message MyMessage {
   *   // The field `value` must be greater than 42.
   *   optional int32 value = 1 [(buf.validate.field).cel = {
   *     id: "my_message.value",
   *     message: "value must be greater than 42",
   *     expression: "this > 42",
   *   }];
   * }
   * ```
   */
  cel?:
    | Constraint[]
    | undefined;
  /**
   * If `required` is true, the field must be populated. A populated field can be
   * described as "serialized in the wire format," which includes:
   *
   * - the following "nullable" fields must be explicitly set to be considered populated:
   *   - singular message fields (whose fields may be unpopulated/default values)
   *   - member fields of a oneof (may be their default value)
   *   - proto3 optional fields (may be their default value)
   *   - proto2 scalar fields (both optional and required)
   * - proto3 scalar fields must be non-zero to be considered populated
   * - repeated and map fields must be non-empty to be considered populated
   *
   * ```proto
   * message MyMessage {
   *   // The field `value` must be set to a non-null value.
   *   optional MyOtherMessage value = 1 [(buf.validate.field).required = true];
   * }
   * ```
   */
  required?:
    | boolean
    | undefined;
  /**
   * Skip validation on the field if its value matches the specified criteria.
   * See Ignore enum for details.
   *
   * ```proto
   * message UpdateRequest {
   *   // The uri rule only applies if the field is populated and not an empty
   *   // string.
   *   optional string url = 1 [
   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE,
   *     (buf.validate.field).string.uri = true,
   *   ];
   * }
   * ```
   */
  ignore?: Ignore | undefined;
  type?:
    | //
    /** Scalar Field Types */
    { $case: "float"; value: FloatRules }
    | { $case: "double"; value: DoubleRules }
    | { $case: "int32"; value: Int32Rules }
    | { $case: "int64"; value: Int64Rules }
    | { $case: "uint32"; value: UInt32Rules }
    | { $case: "uint64"; value: UInt64Rules }
    | { $case: "sint32"; value: SInt32Rules }
    | { $case: "sint64"; value: SInt64Rules }
    | { $case: "fixed32"; value: Fixed32Rules }
    | { $case: "fixed64"; value: Fixed64Rules }
    | { $case: "sfixed32"; value: SFixed32Rules }
    | { $case: "sfixed64"; value: SFixed64Rules }
    | { $case: "bool"; value: BoolRules }
    | { $case: "string"; value: StringRules }
    | { $case: "bytes"; value: BytesRules }
    | //
    /** Complex Field Types */
    { $case: "enum"; value: EnumRules }
    | { $case: "repeated"; value: RepeatedRules }
    | { $case: "map"; value: MapRules }
    | //
    /** Well-Known Field Types */
    { $case: "any"; value: AnyRules }
    | { $case: "duration"; value: DurationRules }
    | { $case: "timestamp"; value: TimestampRules }
    | undefined;
}

/**
 * PredefinedConstraints are custom constraints that can be re-used with
 * multiple fields.
 */
export interface PredefinedConstraints {
  /**
   * `cel` is a repeated field used to represent a textual expression
   * in the Common Expression Language (CEL) syntax. For more information on
   * CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).
   *
   * ```proto
   * message MyMessage {
   *   // The field `value` must be greater than 42.
   *   optional int32 value = 1 [(buf.validate.predefined).cel = {
   *     id: "my_message.value",
   *     message: "value must be greater than 42",
   *     expression: "this > 42",
   *   }];
   * }
   * ```
   */
  cel?: Constraint[] | undefined;
}

/**
 * FloatRules describes the constraints applied to `float` values. These
 * rules may also be applied to the `google.protobuf.FloatValue` Well-Known-Type.
 */
export interface FloatRules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyFloat {
   *   // value must equal 42.0
   *   float value = 1 [(buf.validate.field).float.const = 42.0];
   * }
   * ```
   */
  const?: number | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     *
     * ```proto
     * message MyFloat {
     *   // value must be less than 10.0
     *   float value = 1 [(buf.validate.field).float.lt = 10.0];
     * }
     * ```
     */
    { $case: "lt"; value: number }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MyFloat {
     *   // value must be less than or equal to 10.0
     *   float value = 1 [(buf.validate.field).float.lte = 10.0];
     * }
     * ```
     */
    { $case: "lte"; value: number }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyFloat {
     *   // value must be greater than 5.0 [float.gt]
     *   float value = 1 [(buf.validate.field).float.gt = 5.0];
     *
     *   // value must be greater than 5 and less than 10.0 [float.gt_lt]
     *   float other_value = 2 [(buf.validate.field).float = { gt: 5.0, lt: 10.0 }];
     *
     *   // value must be greater than 10 or less than 5.0 [float.gt_lt_exclusive]
     *   float another_value = 3 [(buf.validate.field).float = { gt: 10.0, lt: 5.0 }];
     * }
     * ```
     */
    { $case: "gt"; value: number }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyFloat {
     *   // value must be greater than or equal to 5.0 [float.gte]
     *   float value = 1 [(buf.validate.field).float.gte = 5.0];
     *
     *   // value must be greater than or equal to 5.0 and less than 10.0 [float.gte_lt]
     *   float other_value = 2 [(buf.validate.field).float = { gte: 5.0, lt: 10.0 }];
     *
     *   // value must be greater than or equal to 10.0 or less than 5.0 [float.gte_lt_exclusive]
     *   float another_value = 3 [(buf.validate.field).float = { gte: 10.0, lt: 5.0 }];
     * }
     * ```
     */
    { $case: "gte"; value: number }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message
   * is generated.
   *
   * ```proto
   * message MyFloat {
   *   // value must be in list [1.0, 2.0, 3.0]
   *   float value = 1 [(buf.validate.field).float = { in: [1.0, 2.0, 3.0] }];
   * }
   * ```
   */
  in?:
    | number[]
    | undefined;
  /**
   * `in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MyFloat {
   *   // value must not be in list [1.0, 2.0, 3.0]
   *   float value = 1 [(buf.validate.field).float = { not_in: [1.0, 2.0, 3.0] }];
   * }
   * ```
   */
  notIn?:
    | number[]
    | undefined;
  /**
   * `finite` requires the field value to be finite. If the field value is
   * infinite or NaN, an error message is generated.
   */
  finite?:
    | boolean
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyFloat {
   *   float value = 1 [
   *     (buf.validate.field).float.example = 1.0,
   *     (buf.validate.field).float.example = "Infinity"
   *   ];
   * }
   * ```
   */
  example?: number[] | undefined;
}

/**
 * DoubleRules describes the constraints applied to `double` values. These
 * rules may also be applied to the `google.protobuf.DoubleValue` Well-Known-Type.
 */
export interface DoubleRules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyDouble {
   *   // value must equal 42.0
   *   double value = 1 [(buf.validate.field).double.const = 42.0];
   * }
   * ```
   */
  const?: number | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MyDouble {
     *   // value must be less than 10.0
     *   double value = 1 [(buf.validate.field).double.lt = 10.0];
     * }
     * ```
     */
    { $case: "lt"; value: number }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified value
     * (field <= value). If the field value is greater than the specified value,
     * an error message is generated.
     *
     * ```proto
     * message MyDouble {
     *   // value must be less than or equal to 10.0
     *   double value = 1 [(buf.validate.field).double.lte = 10.0];
     * }
     * ```
     */
    { $case: "lte"; value: number }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or `lte`,
     * the range is reversed, and the field value must be outside the specified
     * range. If the field value doesn't meet the required conditions, an error
     * message is generated.
     *
     * ```proto
     * message MyDouble {
     *   // value must be greater than 5.0 [double.gt]
     *   double value = 1 [(buf.validate.field).double.gt = 5.0];
     *
     *   // value must be greater than 5 and less than 10.0 [double.gt_lt]
     *   double other_value = 2 [(buf.validate.field).double = { gt: 5.0, lt: 10.0 }];
     *
     *   // value must be greater than 10 or less than 5.0 [double.gt_lt_exclusive]
     *   double another_value = 3 [(buf.validate.field).double = { gt: 10.0, lt: 5.0 }];
     * }
     * ```
     */
    { $case: "gt"; value: number }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyDouble {
     *   // value must be greater than or equal to 5.0 [double.gte]
     *   double value = 1 [(buf.validate.field).double.gte = 5.0];
     *
     *   // value must be greater than or equal to 5.0 and less than 10.0 [double.gte_lt]
     *   double other_value = 2 [(buf.validate.field).double = { gte: 5.0, lt: 10.0 }];
     *
     *   // value must be greater than or equal to 10.0 or less than 5.0 [double.gte_lt_exclusive]
     *   double another_value = 3 [(buf.validate.field).double = { gte: 10.0, lt: 5.0 }];
     * }
     * ```
     */
    { $case: "gte"; value: number }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   *
   * ```proto
   * message MyDouble {
   *   // value must be in list [1.0, 2.0, 3.0]
   *   double value = 1 [(buf.validate.field).double = { in: [1.0, 2.0, 3.0] }];
   * }
   * ```
   */
  in?:
    | number[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MyDouble {
   *   // value must not be in list [1.0, 2.0, 3.0]
   *   double value = 1 [(buf.validate.field).double = { not_in: [1.0, 2.0, 3.0] }];
   * }
   * ```
   */
  notIn?:
    | number[]
    | undefined;
  /**
   * `finite` requires the field value to be finite. If the field value is
   * infinite or NaN, an error message is generated.
   */
  finite?:
    | boolean
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyDouble {
   *   double value = 1 [
   *     (buf.validate.field).double.example = 1.0,
   *     (buf.validate.field).double.example = "Infinity"
   *   ];
   * }
   * ```
   */
  example?: number[] | undefined;
}

/**
 * Int32Rules describes the constraints applied to `int32` values. These
 * rules may also be applied to the `google.protobuf.Int32Value` Well-Known-Type.
 */
export interface Int32Rules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyInt32 {
   *   // value must equal 42
   *   int32 value = 1 [(buf.validate.field).int32.const = 42];
   * }
   * ```
   */
  const?: number | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field
     * < value). If the field value is equal to or greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MyInt32 {
     *   // value must be less than 10
     *   int32 value = 1 [(buf.validate.field).int32.lt = 10];
     * }
     * ```
     */
    { $case: "lt"; value: number }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MyInt32 {
     *   // value must be less than or equal to 10
     *   int32 value = 1 [(buf.validate.field).int32.lte = 10];
     * }
     * ```
     */
    { $case: "lte"; value: number }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyInt32 {
     *   // value must be greater than 5 [int32.gt]
     *   int32 value = 1 [(buf.validate.field).int32.gt = 5];
     *
     *   // value must be greater than 5 and less than 10 [int32.gt_lt]
     *   int32 other_value = 2 [(buf.validate.field).int32 = { gt: 5, lt: 10 }];
     *
     *   // value must be greater than 10 or less than 5 [int32.gt_lt_exclusive]
     *   int32 another_value = 3 [(buf.validate.field).int32 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gt"; value: number }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified value
     * (exclusive). If the value of `gte` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyInt32 {
     *   // value must be greater than or equal to 5 [int32.gte]
     *   int32 value = 1 [(buf.validate.field).int32.gte = 5];
     *
     *   // value must be greater than or equal to 5 and less than 10 [int32.gte_lt]
     *   int32 other_value = 2 [(buf.validate.field).int32 = { gte: 5, lt: 10 }];
     *
     *   // value must be greater than or equal to 10 or less than 5 [int32.gte_lt_exclusive]
     *   int32 another_value = 3 [(buf.validate.field).int32 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gte"; value: number }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   *
   * ```proto
   * message MyInt32 {
   *   // value must be in list [1, 2, 3]
   *   int32 value = 1 [(buf.validate.field).int32 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  in?:
    | number[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error message
   * is generated.
   *
   * ```proto
   * message MyInt32 {
   *   // value must not be in list [1, 2, 3]
   *   int32 value = 1 [(buf.validate.field).int32 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  notIn?:
    | number[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyInt32 {
   *   int32 value = 1 [
   *     (buf.validate.field).int32.example = 1,
   *     (buf.validate.field).int32.example = -10
   *   ];
   * }
   * ```
   */
  example?: number[] | undefined;
}

/**
 * Int64Rules describes the constraints applied to `int64` values. These
 * rules may also be applied to the `google.protobuf.Int64Value` Well-Known-Type.
 */
export interface Int64Rules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyInt64 {
   *   // value must equal 42
   *   int64 value = 1 [(buf.validate.field).int64.const = 42];
   * }
   * ```
   */
  const?: string | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     *
     * ```proto
     * message MyInt64 {
     *   // value must be less than 10
     *   int64 value = 1 [(buf.validate.field).int64.lt = 10];
     * }
     * ```
     */
    { $case: "lt"; value: string }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MyInt64 {
     *   // value must be less than or equal to 10
     *   int64 value = 1 [(buf.validate.field).int64.lte = 10];
     * }
     * ```
     */
    { $case: "lte"; value: string }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyInt64 {
     *   // value must be greater than 5 [int64.gt]
     *   int64 value = 1 [(buf.validate.field).int64.gt = 5];
     *
     *   // value must be greater than 5 and less than 10 [int64.gt_lt]
     *   int64 other_value = 2 [(buf.validate.field).int64 = { gt: 5, lt: 10 }];
     *
     *   // value must be greater than 10 or less than 5 [int64.gt_lt_exclusive]
     *   int64 another_value = 3 [(buf.validate.field).int64 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gt"; value: string }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyInt64 {
     *   // value must be greater than or equal to 5 [int64.gte]
     *   int64 value = 1 [(buf.validate.field).int64.gte = 5];
     *
     *   // value must be greater than or equal to 5 and less than 10 [int64.gte_lt]
     *   int64 other_value = 2 [(buf.validate.field).int64 = { gte: 5, lt: 10 }];
     *
     *   // value must be greater than or equal to 10 or less than 5 [int64.gte_lt_exclusive]
     *   int64 another_value = 3 [(buf.validate.field).int64 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gte"; value: string }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   *
   * ```proto
   * message MyInt64 {
   *   // value must be in list [1, 2, 3]
   *   int64 value = 1 [(buf.validate.field).int64 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  in?:
    | string[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MyInt64 {
   *   // value must not be in list [1, 2, 3]
   *   int64 value = 1 [(buf.validate.field).int64 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  notIn?:
    | string[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyInt64 {
   *   int64 value = 1 [
   *     (buf.validate.field).int64.example = 1,
   *     (buf.validate.field).int64.example = -10
   *   ];
   * }
   * ```
   */
  example?: string[] | undefined;
}

/**
 * UInt32Rules describes the constraints applied to `uint32` values. These
 * rules may also be applied to the `google.protobuf.UInt32Value` Well-Known-Type.
 */
export interface UInt32Rules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyUInt32 {
   *   // value must equal 42
   *   uint32 value = 1 [(buf.validate.field).uint32.const = 42];
   * }
   * ```
   */
  const?: number | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     *
     * ```proto
     * message MyUInt32 {
     *   // value must be less than 10
     *   uint32 value = 1 [(buf.validate.field).uint32.lt = 10];
     * }
     * ```
     */
    { $case: "lt"; value: number }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MyUInt32 {
     *   // value must be less than or equal to 10
     *   uint32 value = 1 [(buf.validate.field).uint32.lte = 10];
     * }
     * ```
     */
    { $case: "lte"; value: number }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyUInt32 {
     *   // value must be greater than 5 [uint32.gt]
     *   uint32 value = 1 [(buf.validate.field).uint32.gt = 5];
     *
     *   // value must be greater than 5 and less than 10 [uint32.gt_lt]
     *   uint32 other_value = 2 [(buf.validate.field).uint32 = { gt: 5, lt: 10 }];
     *
     *   // value must be greater than 10 or less than 5 [uint32.gt_lt_exclusive]
     *   uint32 another_value = 3 [(buf.validate.field).uint32 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gt"; value: number }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyUInt32 {
     *   // value must be greater than or equal to 5 [uint32.gte]
     *   uint32 value = 1 [(buf.validate.field).uint32.gte = 5];
     *
     *   // value must be greater than or equal to 5 and less than 10 [uint32.gte_lt]
     *   uint32 other_value = 2 [(buf.validate.field).uint32 = { gte: 5, lt: 10 }];
     *
     *   // value must be greater than or equal to 10 or less than 5 [uint32.gte_lt_exclusive]
     *   uint32 another_value = 3 [(buf.validate.field).uint32 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gte"; value: number }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   *
   * ```proto
   * message MyUInt32 {
   *   // value must be in list [1, 2, 3]
   *   uint32 value = 1 [(buf.validate.field).uint32 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  in?:
    | number[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MyUInt32 {
   *   // value must not be in list [1, 2, 3]
   *   uint32 value = 1 [(buf.validate.field).uint32 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  notIn?:
    | number[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyUInt32 {
   *   uint32 value = 1 [
   *     (buf.validate.field).uint32.example = 1,
   *     (buf.validate.field).uint32.example = 10
   *   ];
   * }
   * ```
   */
  example?: number[] | undefined;
}

/**
 * UInt64Rules describes the constraints applied to `uint64` values. These
 * rules may also be applied to the `google.protobuf.UInt64Value` Well-Known-Type.
 */
export interface UInt64Rules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyUInt64 {
   *   // value must equal 42
   *   uint64 value = 1 [(buf.validate.field).uint64.const = 42];
   * }
   * ```
   */
  const?: string | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     *
     * ```proto
     * message MyUInt64 {
     *   // value must be less than 10
     *   uint64 value = 1 [(buf.validate.field).uint64.lt = 10];
     * }
     * ```
     */
    { $case: "lt"; value: string }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MyUInt64 {
     *   // value must be less than or equal to 10
     *   uint64 value = 1 [(buf.validate.field).uint64.lte = 10];
     * }
     * ```
     */
    { $case: "lte"; value: string }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyUInt64 {
     *   // value must be greater than 5 [uint64.gt]
     *   uint64 value = 1 [(buf.validate.field).uint64.gt = 5];
     *
     *   // value must be greater than 5 and less than 10 [uint64.gt_lt]
     *   uint64 other_value = 2 [(buf.validate.field).uint64 = { gt: 5, lt: 10 }];
     *
     *   // value must be greater than 10 or less than 5 [uint64.gt_lt_exclusive]
     *   uint64 another_value = 3 [(buf.validate.field).uint64 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gt"; value: string }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyUInt64 {
     *   // value must be greater than or equal to 5 [uint64.gte]
     *   uint64 value = 1 [(buf.validate.field).uint64.gte = 5];
     *
     *   // value must be greater than or equal to 5 and less than 10 [uint64.gte_lt]
     *   uint64 other_value = 2 [(buf.validate.field).uint64 = { gte: 5, lt: 10 }];
     *
     *   // value must be greater than or equal to 10 or less than 5 [uint64.gte_lt_exclusive]
     *   uint64 another_value = 3 [(buf.validate.field).uint64 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gte"; value: string }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   *
   * ```proto
   * message MyUInt64 {
   *   // value must be in list [1, 2, 3]
   *   uint64 value = 1 [(buf.validate.field).uint64 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  in?:
    | string[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MyUInt64 {
   *   // value must not be in list [1, 2, 3]
   *   uint64 value = 1 [(buf.validate.field).uint64 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  notIn?:
    | string[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyUInt64 {
   *   uint64 value = 1 [
   *     (buf.validate.field).uint64.example = 1,
   *     (buf.validate.field).uint64.example = -10
   *   ];
   * }
   * ```
   */
  example?: string[] | undefined;
}

/** SInt32Rules describes the constraints applied to `sint32` values. */
export interface SInt32Rules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MySInt32 {
   *   // value must equal 42
   *   sint32 value = 1 [(buf.validate.field).sint32.const = 42];
   * }
   * ```
   */
  const?: number | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field
     * < value). If the field value is equal to or greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MySInt32 {
     *   // value must be less than 10
     *   sint32 value = 1 [(buf.validate.field).sint32.lt = 10];
     * }
     * ```
     */
    { $case: "lt"; value: number }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MySInt32 {
     *   // value must be less than or equal to 10
     *   sint32 value = 1 [(buf.validate.field).sint32.lte = 10];
     * }
     * ```
     */
    { $case: "lte"; value: number }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MySInt32 {
     *   // value must be greater than 5 [sint32.gt]
     *   sint32 value = 1 [(buf.validate.field).sint32.gt = 5];
     *
     *   // value must be greater than 5 and less than 10 [sint32.gt_lt]
     *   sint32 other_value = 2 [(buf.validate.field).sint32 = { gt: 5, lt: 10 }];
     *
     *   // value must be greater than 10 or less than 5 [sint32.gt_lt_exclusive]
     *   sint32 another_value = 3 [(buf.validate.field).sint32 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gt"; value: number }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MySInt32 {
     *  // value must be greater than or equal to 5 [sint32.gte]
     *  sint32 value = 1 [(buf.validate.field).sint32.gte = 5];
     *
     *  // value must be greater than or equal to 5 and less than 10 [sint32.gte_lt]
     *  sint32 other_value = 2 [(buf.validate.field).sint32 = { gte: 5, lt: 10 }];
     *
     *  // value must be greater than or equal to 10 or less than 5 [sint32.gte_lt_exclusive]
     *  sint32 another_value = 3 [(buf.validate.field).sint32 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gte"; value: number }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   *
   * ```proto
   * message MySInt32 {
   *   // value must be in list [1, 2, 3]
   *   sint32 value = 1 [(buf.validate.field).sint32 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  in?:
    | number[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MySInt32 {
   *   // value must not be in list [1, 2, 3]
   *   sint32 value = 1 [(buf.validate.field).sint32 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  notIn?:
    | number[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MySInt32 {
   *   sint32 value = 1 [
   *     (buf.validate.field).sint32.example = 1,
   *     (buf.validate.field).sint32.example = -10
   *   ];
   * }
   * ```
   */
  example?: number[] | undefined;
}

/** SInt64Rules describes the constraints applied to `sint64` values. */
export interface SInt64Rules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MySInt64 {
   *   // value must equal 42
   *   sint64 value = 1 [(buf.validate.field).sint64.const = 42];
   * }
   * ```
   */
  const?: string | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field
     * < value). If the field value is equal to or greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MySInt64 {
     *   // value must be less than 10
     *   sint64 value = 1 [(buf.validate.field).sint64.lt = 10];
     * }
     * ```
     */
    { $case: "lt"; value: string }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MySInt64 {
     *   // value must be less than or equal to 10
     *   sint64 value = 1 [(buf.validate.field).sint64.lte = 10];
     * }
     * ```
     */
    { $case: "lte"; value: string }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MySInt64 {
     *   // value must be greater than 5 [sint64.gt]
     *   sint64 value = 1 [(buf.validate.field).sint64.gt = 5];
     *
     *   // value must be greater than 5 and less than 10 [sint64.gt_lt]
     *   sint64 other_value = 2 [(buf.validate.field).sint64 = { gt: 5, lt: 10 }];
     *
     *   // value must be greater than 10 or less than 5 [sint64.gt_lt_exclusive]
     *   sint64 another_value = 3 [(buf.validate.field).sint64 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gt"; value: string }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MySInt64 {
     *   // value must be greater than or equal to 5 [sint64.gte]
     *   sint64 value = 1 [(buf.validate.field).sint64.gte = 5];
     *
     *   // value must be greater than or equal to 5 and less than 10 [sint64.gte_lt]
     *   sint64 other_value = 2 [(buf.validate.field).sint64 = { gte: 5, lt: 10 }];
     *
     *   // value must be greater than or equal to 10 or less than 5 [sint64.gte_lt_exclusive]
     *   sint64 another_value = 3 [(buf.validate.field).sint64 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gte"; value: string }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message
   * is generated.
   *
   * ```proto
   * message MySInt64 {
   *   // value must be in list [1, 2, 3]
   *   sint64 value = 1 [(buf.validate.field).sint64 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  in?:
    | string[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MySInt64 {
   *   // value must not be in list [1, 2, 3]
   *   sint64 value = 1 [(buf.validate.field).sint64 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  notIn?:
    | string[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MySInt64 {
   *   sint64 value = 1 [
   *     (buf.validate.field).sint64.example = 1,
   *     (buf.validate.field).sint64.example = -10
   *   ];
   * }
   * ```
   */
  example?: string[] | undefined;
}

/** Fixed32Rules describes the constraints applied to `fixed32` values. */
export interface Fixed32Rules {
  /**
   * `const` requires the field value to exactly match the specified value.
   * If the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyFixed32 {
   *   // value must equal 42
   *   fixed32 value = 1 [(buf.validate.field).fixed32.const = 42];
   * }
   * ```
   */
  const?: number | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     *
     * ```proto
     * message MyFixed32 {
     *   // value must be less than 10
     *   fixed32 value = 1 [(buf.validate.field).fixed32.lt = 10];
     * }
     * ```
     */
    { $case: "lt"; value: number }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MyFixed32 {
     *   // value must be less than or equal to 10
     *   fixed32 value = 1 [(buf.validate.field).fixed32.lte = 10];
     * }
     * ```
     */
    { $case: "lte"; value: number }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyFixed32 {
     *   // value must be greater than 5 [fixed32.gt]
     *   fixed32 value = 1 [(buf.validate.field).fixed32.gt = 5];
     *
     *   // value must be greater than 5 and less than 10 [fixed32.gt_lt]
     *   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gt: 5, lt: 10 }];
     *
     *   // value must be greater than 10 or less than 5 [fixed32.gt_lt_exclusive]
     *   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gt"; value: number }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyFixed32 {
     *   // value must be greater than or equal to 5 [fixed32.gte]
     *   fixed32 value = 1 [(buf.validate.field).fixed32.gte = 5];
     *
     *   // value must be greater than or equal to 5 and less than 10 [fixed32.gte_lt]
     *   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gte: 5, lt: 10 }];
     *
     *   // value must be greater than or equal to 10 or less than 5 [fixed32.gte_lt_exclusive]
     *   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gte"; value: number }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message
   * is generated.
   *
   * ```proto
   * message MyFixed32 {
   *   // value must be in list [1, 2, 3]
   *   fixed32 value = 1 [(buf.validate.field).fixed32 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  in?:
    | number[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MyFixed32 {
   *   // value must not be in list [1, 2, 3]
   *   fixed32 value = 1 [(buf.validate.field).fixed32 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  notIn?:
    | number[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyFixed32 {
   *   fixed32 value = 1 [
   *     (buf.validate.field).fixed32.example = 1,
   *     (buf.validate.field).fixed32.example = 2
   *   ];
   * }
   * ```
   */
  example?: number[] | undefined;
}

/** Fixed64Rules describes the constraints applied to `fixed64` values. */
export interface Fixed64Rules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyFixed64 {
   *   // value must equal 42
   *   fixed64 value = 1 [(buf.validate.field).fixed64.const = 42];
   * }
   * ```
   */
  const?: string | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     *
     * ```proto
     * message MyFixed64 {
     *   // value must be less than 10
     *   fixed64 value = 1 [(buf.validate.field).fixed64.lt = 10];
     * }
     * ```
     */
    { $case: "lt"; value: string }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MyFixed64 {
     *   // value must be less than or equal to 10
     *   fixed64 value = 1 [(buf.validate.field).fixed64.lte = 10];
     * }
     * ```
     */
    { $case: "lte"; value: string }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyFixed64 {
     *   // value must be greater than 5 [fixed64.gt]
     *   fixed64 value = 1 [(buf.validate.field).fixed64.gt = 5];
     *
     *   // value must be greater than 5 and less than 10 [fixed64.gt_lt]
     *   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gt: 5, lt: 10 }];
     *
     *   // value must be greater than 10 or less than 5 [fixed64.gt_lt_exclusive]
     *   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gt"; value: string }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyFixed64 {
     *   // value must be greater than or equal to 5 [fixed64.gte]
     *   fixed64 value = 1 [(buf.validate.field).fixed64.gte = 5];
     *
     *   // value must be greater than or equal to 5 and less than 10 [fixed64.gte_lt]
     *   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gte: 5, lt: 10 }];
     *
     *   // value must be greater than or equal to 10 or less than 5 [fixed64.gte_lt_exclusive]
     *   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gte"; value: string }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   *
   * ```proto
   * message MyFixed64 {
   *   // value must be in list [1, 2, 3]
   *   fixed64 value = 1 [(buf.validate.field).fixed64 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  in?:
    | string[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MyFixed64 {
   *   // value must not be in list [1, 2, 3]
   *   fixed64 value = 1 [(buf.validate.field).fixed64 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  notIn?:
    | string[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyFixed64 {
   *   fixed64 value = 1 [
   *     (buf.validate.field).fixed64.example = 1,
   *     (buf.validate.field).fixed64.example = 2
   *   ];
   * }
   * ```
   */
  example?: string[] | undefined;
}

/** SFixed32Rules describes the constraints applied to `fixed32` values. */
export interface SFixed32Rules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MySFixed32 {
   *   // value must equal 42
   *   sfixed32 value = 1 [(buf.validate.field).sfixed32.const = 42];
   * }
   * ```
   */
  const?: number | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     *
     * ```proto
     * message MySFixed32 {
     *   // value must be less than 10
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.lt = 10];
     * }
     * ```
     */
    { $case: "lt"; value: number }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MySFixed32 {
     *   // value must be less than or equal to 10
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.lte = 10];
     * }
     * ```
     */
    { $case: "lte"; value: number }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MySFixed32 {
     *   // value must be greater than 5 [sfixed32.gt]
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.gt = 5];
     *
     *   // value must be greater than 5 and less than 10 [sfixed32.gt_lt]
     *   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gt: 5, lt: 10 }];
     *
     *   // value must be greater than 10 or less than 5 [sfixed32.gt_lt_exclusive]
     *   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gt"; value: number }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MySFixed32 {
     *   // value must be greater than or equal to 5 [sfixed32.gte]
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.gte = 5];
     *
     *   // value must be greater than or equal to 5 and less than 10 [sfixed32.gte_lt]
     *   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gte: 5, lt: 10 }];
     *
     *   // value must be greater than or equal to 10 or less than 5 [sfixed32.gte_lt_exclusive]
     *   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gte"; value: number }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   *
   * ```proto
   * message MySFixed32 {
   *   // value must be in list [1, 2, 3]
   *   sfixed32 value = 1 [(buf.validate.field).sfixed32 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  in?:
    | number[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MySFixed32 {
   *   // value must not be in list [1, 2, 3]
   *   sfixed32 value = 1 [(buf.validate.field).sfixed32 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  notIn?:
    | number[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MySFixed32 {
   *   sfixed32 value = 1 [
   *     (buf.validate.field).sfixed32.example = 1,
   *     (buf.validate.field).sfixed32.example = 2
   *   ];
   * }
   * ```
   */
  example?: number[] | undefined;
}

/** SFixed64Rules describes the constraints applied to `fixed64` values. */
export interface SFixed64Rules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MySFixed64 {
   *   // value must equal 42
   *   sfixed64 value = 1 [(buf.validate.field).sfixed64.const = 42];
   * }
   * ```
   */
  const?: string | undefined;
  lessThan?:
    | //
    /**
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     *
     * ```proto
     * message MySFixed64 {
     *   // value must be less than 10
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.lt = 10];
     * }
     * ```
     */
    { $case: "lt"; value: string }
    | //
    /**
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     *
     * ```proto
     * message MySFixed64 {
     *   // value must be less than or equal to 10
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.lte = 10];
     * }
     * ```
     */
    { $case: "lte"; value: string }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MySFixed64 {
     *   // value must be greater than 5 [sfixed64.gt]
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.gt = 5];
     *
     *   // value must be greater than 5 and less than 10 [sfixed64.gt_lt]
     *   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gt: 5, lt: 10 }];
     *
     *   // value must be greater than 10 or less than 5 [sfixed64.gt_lt_exclusive]
     *   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gt"; value: string }
    | //
    /**
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MySFixed64 {
     *   // value must be greater than or equal to 5 [sfixed64.gte]
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.gte = 5];
     *
     *   // value must be greater than or equal to 5 and less than 10 [sfixed64.gte_lt]
     *   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gte: 5, lt: 10 }];
     *
     *   // value must be greater than or equal to 10 or less than 5 [sfixed64.gte_lt_exclusive]
     *   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    { $case: "gte"; value: string }
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   *
   * ```proto
   * message MySFixed64 {
   *   // value must be in list [1, 2, 3]
   *   sfixed64 value = 1 [(buf.validate.field).sfixed64 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  in?:
    | string[]
    | undefined;
  /**
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MySFixed64 {
   *   // value must not be in list [1, 2, 3]
   *   sfixed64 value = 1 [(buf.validate.field).sfixed64 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  notIn?:
    | string[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MySFixed64 {
   *   sfixed64 value = 1 [
   *     (buf.validate.field).sfixed64.example = 1,
   *     (buf.validate.field).sfixed64.example = 2
   *   ];
   * }
   * ```
   */
  example?: string[] | undefined;
}

/**
 * BoolRules describes the constraints applied to `bool` values. These rules
 * may also be applied to the `google.protobuf.BoolValue` Well-Known-Type.
 */
export interface BoolRules {
  /**
   * `const` requires the field value to exactly match the specified boolean value.
   * If the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyBool {
   *   // value must equal true
   *   bool value = 1 [(buf.validate.field).bool.const = true];
   * }
   * ```
   */
  const?:
    | boolean
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyBool {
   *   bool value = 1 [
   *     (buf.validate.field).bool.example = 1,
   *     (buf.validate.field).bool.example = 2
   *   ];
   * }
   * ```
   */
  example?: boolean[] | undefined;
}

/**
 * StringRules describes the constraints applied to `string` values These
 * rules may also be applied to the `google.protobuf.StringValue` Well-Known-Type.
 */
export interface StringRules {
  /**
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyString {
   *   // value must equal `hello`
   *   string value = 1 [(buf.validate.field).string.const = "hello"];
   * }
   * ```
   */
  const?:
    | string
    | undefined;
  /**
   * `len` dictates that the field value must have the specified
   * number of characters (Unicode code points), which may differ from the number
   * of bytes in the string. If the field value does not meet the specified
   * length, an error message will be generated.
   *
   * ```proto
   * message MyString {
   *   // value length must be 5 characters
   *   string value = 1 [(buf.validate.field).string.len = 5];
   * }
   * ```
   */
  len?:
    | string
    | undefined;
  /**
   * `min_len` specifies that the field value must have at least the specified
   * number of characters (Unicode code points), which may differ from the number
   * of bytes in the string. If the field value contains fewer characters, an error
   * message will be generated.
   *
   * ```proto
   * message MyString {
   *   // value length must be at least 3 characters
   *   string value = 1 [(buf.validate.field).string.min_len = 3];
   * }
   * ```
   */
  minLen?:
    | string
    | undefined;
  /**
   * `max_len` specifies that the field value must have no more than the specified
   * number of characters (Unicode code points), which may differ from the
   * number of bytes in the string. If the field value contains more characters,
   * an error message will be generated.
   *
   * ```proto
   * message MyString {
   *   // value length must be at most 10 characters
   *   string value = 1 [(buf.validate.field).string.max_len = 10];
   * }
   * ```
   */
  maxLen?:
    | string
    | undefined;
  /**
   * `len_bytes` dictates that the field value must have the specified number of
   * bytes. If the field value does not match the specified length in bytes,
   * an error message will be generated.
   *
   * ```proto
   * message MyString {
   *   // value length must be 6 bytes
   *   string value = 1 [(buf.validate.field).string.len_bytes = 6];
   * }
   * ```
   */
  lenBytes?:
    | string
    | undefined;
  /**
   * `min_bytes` specifies that the field value must have at least the specified
   * number of bytes. If the field value contains fewer bytes, an error message
   * will be generated.
   *
   * ```proto
   * message MyString {
   *   // value length must be at least 4 bytes
   *   string value = 1 [(buf.validate.field).string.min_bytes = 4];
   * }
   *
   * ```
   */
  minBytes?:
    | string
    | undefined;
  /**
   * `max_bytes` specifies that the field value must have no more than the
   * specified number of bytes. If the field value contains more bytes, an
   * error message will be generated.
   *
   * ```proto
   * message MyString {
   *   // value length must be at most 8 bytes
   *   string value = 1 [(buf.validate.field).string.max_bytes = 8];
   * }
   * ```
   */
  maxBytes?:
    | string
    | undefined;
  /**
   * `pattern` specifies that the field value must match the specified
   * regular expression (RE2 syntax), with the expression provided without any
   * delimiters. If the field value doesn't match the regular expression, an
   * error message will be generated.
   *
   * ```proto
   * message MyString {
   *   // value does not match regex pattern `^[a-zA-Z]//$`
   *   string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
   * }
   * ```
   */
  pattern?:
    | string
    | undefined;
  /**
   * `prefix` specifies that the field value must have the
   * specified substring at the beginning of the string. If the field value
   * doesn't start with the specified prefix, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   *   // value does not have prefix `pre`
   *   string value = 1 [(buf.validate.field).string.prefix = "pre"];
   * }
   * ```
   */
  prefix?:
    | string
    | undefined;
  /**
   * `suffix` specifies that the field value must have the
   * specified substring at the end of the string. If the field value doesn't
   * end with the specified suffix, an error message will be generated.
   *
   * ```proto
   * message MyString {
   *   // value does not have suffix `post`
   *   string value = 1 [(buf.validate.field).string.suffix = "post"];
   * }
   * ```
   */
  suffix?:
    | string
    | undefined;
  /**
   * `contains` specifies that the field value must have the
   * specified substring anywhere in the string. If the field value doesn't
   * contain the specified substring, an error message will be generated.
   *
   * ```proto
   * message MyString {
   *   // value does not contain substring `inside`.
   *   string value = 1 [(buf.validate.field).string.contains = "inside"];
   * }
   * ```
   */
  contains?:
    | string
    | undefined;
  /**
   * `not_contains` specifies that the field value must not have the
   * specified substring anywhere in the string. If the field value contains
   * the specified substring, an error message will be generated.
   *
   * ```proto
   * message MyString {
   *   // value contains substring `inside`.
   *   string value = 1 [(buf.validate.field).string.not_contains = "inside"];
   * }
   * ```
   */
  notContains?:
    | string
    | undefined;
  /**
   * `in` specifies that the field value must be equal to one of the specified
   * values. If the field value isn't one of the specified values, an error
   * message will be generated.
   *
   * ```proto
   * message MyString {
   *   // value must be in list ["apple", "banana"]
   *   string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
   * }
   * ```
   */
  in?:
    | string[]
    | undefined;
  /**
   * `not_in` specifies that the field value cannot be equal to any
   * of the specified values. If the field value is one of the specified values,
   * an error message will be generated.
   * ```proto
   * message MyString {
   *   // value must not be in list ["orange", "grape"]
   *   string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
   * }
   * ```
   */
  notIn?:
    | string[]
    | undefined;
  /**
   * `WellKnown` rules provide advanced constraints against common string
   * patterns
   */
  wellKnown?:
    | //
    /**
     * `email` specifies that the field value must be a valid email address
     * (addr-spec only) as defined by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1).
     * If the field value isn't a valid email address, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid email address
     *   string value = 1 [(buf.validate.field).string.email = true];
     * }
     * ```
     */
    { $case: "email"; value: boolean }
    | //
    /**
     * `hostname` specifies that the field value must be a valid
     * hostname as defined by [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034#section-3.5). This constraint doesn't support
     * internationalized domain names (IDNs). If the field value isn't a
     * valid hostname, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid hostname
     *   string value = 1 [(buf.validate.field).string.hostname = true];
     * }
     * ```
     */
    { $case: "hostname"; value: boolean }
    | //
    /**
     * `ip` specifies that the field value must be a valid IP
     * (v4 or v6) address, without surrounding square brackets for IPv6 addresses.
     * If the field value isn't a valid IP address, an error message will be
     * generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid IP address
     *   string value = 1 [(buf.validate.field).string.ip = true];
     * }
     * ```
     */
    { $case: "ip"; value: boolean }
    | //
    /**
     * `ipv4` specifies that the field value must be a valid IPv4
     * address. If the field value isn't a valid IPv4 address, an error message
     * will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid IPv4 address
     *   string value = 1 [(buf.validate.field).string.ipv4 = true];
     * }
     * ```
     */
    { $case: "ipv4"; value: boolean }
    | //
    /**
     * `ipv6` specifies that the field value must be a valid
     * IPv6 address, without surrounding square brackets. If the field value is
     * not a valid IPv6 address, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid IPv6 address
     *   string value = 1 [(buf.validate.field).string.ipv6 = true];
     * }
     * ```
     */
    { $case: "ipv6"; value: boolean }
    | //
    /**
     * `uri` specifies that the field value must be a valid URI as defined by
     * [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986#section-3).
     *
     * If the field value isn't a valid URI, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid URI
     *   string value = 1 [(buf.validate.field).string.uri = true];
     * }
     * ```
     */
    { $case: "uri"; value: boolean }
    | //
    /**
     * `uri_ref` specifies that the field value must be a valid URI Reference as
     * defined by [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986#section-4.1).
     *
     * A URI Reference is either a [URI](https://datatracker.ietf.org/doc/html/rfc3986#section-3),
     * or a [Relative Reference](https://datatracker.ietf.org/doc/html/rfc3986#section-4.2).
     *
     * If the field value isn't a valid URI Reference, an error message will be
     * generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid URI Reference
     *   string value = 1 [(buf.validate.field).string.uri_ref = true];
     * }
     * ```
     */
    { $case: "uriRef"; value: boolean }
    | //
    /**
     * `address` specifies that the field value must be either a valid hostname
     * as defined by [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034#section-3.5)
     * (which doesn't support internationalized domain names or IDNs) or a valid
     * IP (v4 or v6). If the field value isn't a valid hostname or IP, an error
     * message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid hostname, or ip address
     *   string value = 1 [(buf.validate.field).string.address = true];
     * }
     * ```
     */
    { $case: "address"; value: boolean }
    | //
    /**
     * `uuid` specifies that the field value must be a valid UUID as defined by
     * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2). If the
     * field value isn't a valid UUID, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid UUID
     *   string value = 1 [(buf.validate.field).string.uuid = true];
     * }
     * ```
     */
    { $case: "uuid"; value: boolean }
    | //
    /**
     * `tuuid` (trimmed UUID) specifies that the field value must be a valid UUID as
     * defined by [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2) with all dashes
     * omitted. If the field value isn't a valid UUID without dashes, an error message
     * will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid trimmed UUID
     *   string value = 1 [(buf.validate.field).string.tuuid = true];
     * }
     * ```
     */
    { $case: "tuuid"; value: boolean }
    | //
    /**
     * `ip_with_prefixlen` specifies that the field value must be a valid IP (v4 or v6)
     * address with prefix length. If the field value isn't a valid IP with prefix
     * length, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid IP with prefix length
     *    string value = 1 [(buf.validate.field).string.ip_with_prefixlen = true];
     * }
     * ```
     */
    { $case: "ipWithPrefixlen"; value: boolean }
    | //
    /**
     * `ipv4_with_prefixlen` specifies that the field value must be a valid
     * IPv4 address with prefix.
     * If the field value isn't a valid IPv4 address with prefix length,
     * an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid IPv4 address with prefix length
     *    string value = 1 [(buf.validate.field).string.ipv4_with_prefixlen = true];
     * }
     * ```
     */
    { $case: "ipv4WithPrefixlen"; value: boolean }
    | //
    /**
     * `ipv6_with_prefixlen` specifies that the field value must be a valid
     * IPv6 address with prefix length.
     * If the field value is not a valid IPv6 address with prefix length,
     * an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid IPv6 address prefix length
     *    string value = 1 [(buf.validate.field).string.ipv6_with_prefixlen = true];
     * }
     * ```
     */
    { $case: "ipv6WithPrefixlen"; value: boolean }
    | //
    /**
     * `ip_prefix` specifies that the field value must be a valid IP (v4 or v6) prefix.
     * If the field value isn't a valid IP prefix, an error message will be
     * generated. The prefix must have all zeros for the masked bits of the prefix (e.g.,
     * `127.0.0.0/16`, not `127.0.0.1/16`).
     *
     * ```proto
     * message MyString {
     *   // value must be a valid IP prefix
     *    string value = 1 [(buf.validate.field).string.ip_prefix = true];
     * }
     * ```
     */
    { $case: "ipPrefix"; value: boolean }
    | //
    /**
     * `ipv4_prefix` specifies that the field value must be a valid IPv4
     * prefix. If the field value isn't a valid IPv4 prefix, an error message
     * will be generated. The prefix must have all zeros for the masked bits of
     * the prefix (e.g., `127.0.0.0/16`, not `127.0.0.1/16`).
     *
     * ```proto
     * message MyString {
     *   // value must be a valid IPv4 prefix
     *    string value = 1 [(buf.validate.field).string.ipv4_prefix = true];
     * }
     * ```
     */
    { $case: "ipv4Prefix"; value: boolean }
    | //
    /**
     * `ipv6_prefix` specifies that the field value must be a valid IPv6 prefix.
     * If the field value is not a valid IPv6 prefix, an error message will be
     * generated. The prefix must have all zeros for the masked bits of the prefix
     * (e.g., `2001:db8::/48`, not `2001:db8::1/48`).
     *
     * ```proto
     * message MyString {
     *   // value must be a valid IPv6 prefix
     *    string value = 1 [(buf.validate.field).string.ipv6_prefix = true];
     * }
     * ```
     */
    { $case: "ipv6Prefix"; value: boolean }
    | //
    /**
     * `host_and_port` specifies the field value must be a valid host and port
     * pair. The host must be a valid hostname or IP address while the port
     * must be in the range of 0-65535, inclusive. IPv6 addresses must be delimited
     * with square brackets (e.g., `[::1]:1234`).
     */
    { $case: "hostAndPort"; value: boolean }
    | //
    /**
     * `well_known_regex` specifies a common well-known pattern
     * defined as a regex. If the field value doesn't match the well-known
     * regex, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be a valid HTTP header value
     *   string value = 1 [(buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_VALUE];
     * }
     * ```
     *
     * #### KnownRegex
     *
     * `well_known_regex` contains some well-known patterns.
     *
     * | Name                          | Number | Description                               |
     * |-------------------------------|--------|-------------------------------------------|
     * | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
     * | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2)  |
     * | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4) |
     */
    { $case: "wellKnownRegex"; value: KnownRegex }
    | undefined;
  /**
   * This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
   * enable strict header validation. By default, this is true, and HTTP header
   * validations are [RFC-compliant](https://datatracker.ietf.org/doc/html/rfc7230#section-3). Setting to false will enable looser
   * validations that only disallow `\r\n\0` characters, which can be used to
   * bypass header matching rules.
   *
   * ```proto
   * message MyString {
   *   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
   *   string value = 1 [(buf.validate.field).string.strict = false];
   * }
   * ```
   */
  strict?:
    | boolean
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyString {
   *   string value = 1 [
   *     (buf.validate.field).string.example = "hello",
   *     (buf.validate.field).string.example = "world"
   *   ];
   * }
   * ```
   */
  example?: string[] | undefined;
}

/**
 * BytesRules describe the constraints applied to `bytes` values. These rules
 * may also be applied to the `google.protobuf.BytesValue` Well-Known-Type.
 */
export interface BytesRules {
  /**
   * `const` requires the field value to exactly match the specified bytes
   * value. If the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyBytes {
   *   // value must be "\x01\x02\x03\x04"
   *   bytes value = 1 [(buf.validate.field).bytes.const = "\x01\x02\x03\x04"];
   * }
   * ```
   */
  const?:
    | Buffer
    | undefined;
  /**
   * `len` requires the field value to have the specified length in bytes.
   * If the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyBytes {
   *   // value length must be 4 bytes.
   *   optional bytes value = 1 [(buf.validate.field).bytes.len = 4];
   * }
   * ```
   */
  len?:
    | string
    | undefined;
  /**
   * `min_len` requires the field value to have at least the specified minimum
   * length in bytes.
   * If the field value doesn't meet the requirement, an error message is generated.
   *
   * ```proto
   * message MyBytes {
   *   // value length must be at least 2 bytes.
   *   optional bytes value = 1 [(buf.validate.field).bytes.min_len = 2];
   * }
   * ```
   */
  minLen?:
    | string
    | undefined;
  /**
   * `max_len` requires the field value to have at most the specified maximum
   * length in bytes.
   * If the field value exceeds the requirement, an error message is generated.
   *
   * ```proto
   * message MyBytes {
   *   // value must be at most 6 bytes.
   *   optional bytes value = 1 [(buf.validate.field).bytes.max_len = 6];
   * }
   * ```
   */
  maxLen?:
    | string
    | undefined;
  /**
   * `pattern` requires the field value to match the specified regular
   * expression ([RE2 syntax](https://github.com/google/re2/wiki/Syntax)).
   * The value of the field must be valid UTF-8 or validation will fail with a
   * runtime error.
   * If the field value doesn't match the pattern, an error message is generated.
   *
   * ```proto
   * message MyBytes {
   *   // value must match regex pattern "^[a-zA-Z0-9]+$".
   *   optional bytes value = 1 [(buf.validate.field).bytes.pattern = "^[a-zA-Z0-9]+$"];
   * }
   * ```
   */
  pattern?:
    | string
    | undefined;
  /**
   * `prefix` requires the field value to have the specified bytes at the
   * beginning of the string.
   * If the field value doesn't meet the requirement, an error message is generated.
   *
   * ```proto
   * message MyBytes {
   *   // value does not have prefix \x01\x02
   *   optional bytes value = 1 [(buf.validate.field).bytes.prefix = "\x01\x02"];
   * }
   * ```
   */
  prefix?:
    | Buffer
    | undefined;
  /**
   * `suffix` requires the field value to have the specified bytes at the end
   * of the string.
   * If the field value doesn't meet the requirement, an error message is generated.
   *
   * ```proto
   * message MyBytes {
   *   // value does not have suffix \x03\x04
   *   optional bytes value = 1 [(buf.validate.field).bytes.suffix = "\x03\x04"];
   * }
   * ```
   */
  suffix?:
    | Buffer
    | undefined;
  /**
   * `contains` requires the field value to have the specified bytes anywhere in
   * the string.
   * If the field value doesn't meet the requirement, an error message is generated.
   *
   * ```protobuf
   * message MyBytes {
   *   // value does not contain \x02\x03
   *   optional bytes value = 1 [(buf.validate.field).bytes.contains = "\x02\x03"];
   * }
   * ```
   */
  contains?:
    | Buffer
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the specified
   * values. If the field value doesn't match any of the specified values, an
   * error message is generated.
   *
   * ```protobuf
   * message MyBytes {
   *   // value must in ["\x01\x02", "\x02\x03", "\x03\x04"]
   *   optional bytes value = 1 [(buf.validate.field).bytes.in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
   * }
   * ```
   */
  in?:
    | Buffer[]
    | undefined;
  /**
   * `not_in` requires the field value to be not equal to any of the specified
   * values.
   * If the field value matches any of the specified values, an error message is
   * generated.
   *
   * ```proto
   * message MyBytes {
   *   // value must not in ["\x01\x02", "\x02\x03", "\x03\x04"]
   *   optional bytes value = 1 [(buf.validate.field).bytes.not_in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
   * }
   * ```
   */
  notIn?:
    | Buffer[]
    | undefined;
  /**
   * WellKnown rules provide advanced constraints against common byte
   * patterns
   */
  wellKnown?:
    | //
    /**
     * `ip` ensures that the field `value` is a valid IP address (v4 or v6) in byte format.
     * If the field value doesn't meet this constraint, an error message is generated.
     *
     * ```proto
     * message MyBytes {
     *   // value must be a valid IP address
     *   optional bytes value = 1 [(buf.validate.field).bytes.ip = true];
     * }
     * ```
     */
    { $case: "ip"; value: boolean }
    | //
    /**
     * `ipv4` ensures that the field `value` is a valid IPv4 address in byte format.
     * If the field value doesn't meet this constraint, an error message is generated.
     *
     * ```proto
     * message MyBytes {
     *   // value must be a valid IPv4 address
     *   optional bytes value = 1 [(buf.validate.field).bytes.ipv4 = true];
     * }
     * ```
     */
    { $case: "ipv4"; value: boolean }
    | //
    /**
     * `ipv6` ensures that the field `value` is a valid IPv6 address in byte format.
     * If the field value doesn't meet this constraint, an error message is generated.
     * ```proto
     * message MyBytes {
     *   // value must be a valid IPv6 address
     *   optional bytes value = 1 [(buf.validate.field).bytes.ipv6 = true];
     * }
     * ```
     */
    { $case: "ipv6"; value: boolean }
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyBytes {
   *   bytes value = 1 [
   *     (buf.validate.field).bytes.example = "\x01\x02",
   *     (buf.validate.field).bytes.example = "\x02\x03"
   *   ];
   * }
   * ```
   */
  example?: Buffer[] | undefined;
}

/** EnumRules describe the constraints applied to `enum` values. */
export interface EnumRules {
  /**
   * `const` requires the field value to exactly match the specified enum value.
   * If the field value doesn't match, an error message is generated.
   *
   * ```proto
   * enum MyEnum {
   *   MY_ENUM_UNSPECIFIED = 0;
   *   MY_ENUM_VALUE1 = 1;
   *   MY_ENUM_VALUE2 = 2;
   * }
   *
   * message MyMessage {
   *   // The field `value` must be exactly MY_ENUM_VALUE1.
   *   MyEnum value = 1 [(buf.validate.field).enum.const = 1];
   * }
   * ```
   */
  const?:
    | number
    | undefined;
  /**
   * `defined_only` requires the field value to be one of the defined values for
   * this enum, failing on any undefined value.
   *
   * ```proto
   * enum MyEnum {
   *   MY_ENUM_UNSPECIFIED = 0;
   *   MY_ENUM_VALUE1 = 1;
   *   MY_ENUM_VALUE2 = 2;
   * }
   *
   * message MyMessage {
   *   // The field `value` must be a defined value of MyEnum.
   *   MyEnum value = 1 [(buf.validate.field).enum.defined_only = true];
   * }
   * ```
   */
  definedOnly?:
    | boolean
    | undefined;
  /**
   * `in` requires the field value to be equal to one of the
   * specified enum values. If the field value doesn't match any of the
   * specified values, an error message is generated.
   *
   * ```proto
   * enum MyEnum {
   *   MY_ENUM_UNSPECIFIED = 0;
   *   MY_ENUM_VALUE1 = 1;
   *   MY_ENUM_VALUE2 = 2;
   * }
   *
   * message MyMessage {
   *   // The field `value` must be equal to one of the specified values.
   *   MyEnum value = 1 [(buf.validate.field).enum = { in: [1, 2]}];
   * }
   * ```
   */
  in?:
    | number[]
    | undefined;
  /**
   * `not_in` requires the field value to be not equal to any of the
   * specified enum values. If the field value matches one of the specified
   * values, an error message is generated.
   *
   * ```proto
   * enum MyEnum {
   *   MY_ENUM_UNSPECIFIED = 0;
   *   MY_ENUM_VALUE1 = 1;
   *   MY_ENUM_VALUE2 = 2;
   * }
   *
   * message MyMessage {
   *   // The field `value` must not be equal to any of the specified values.
   *   MyEnum value = 1 [(buf.validate.field).enum = { not_in: [1, 2]}];
   * }
   * ```
   */
  notIn?:
    | number[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * enum MyEnum {
   *   MY_ENUM_UNSPECIFIED = 0;
   *   MY_ENUM_VALUE1 = 1;
   *   MY_ENUM_VALUE2 = 2;
   * }
   *
   * message MyMessage {
   *     (buf.validate.field).enum.example = 1,
   *     (buf.validate.field).enum.example = 2
   * }
   * ```
   */
  example?: number[] | undefined;
}

/** RepeatedRules describe the constraints applied to `repeated` values. */
export interface RepeatedRules {
  /**
   * `min_items` requires that this field must contain at least the specified
   * minimum number of items.
   *
   * Note that `min_items = 1` is equivalent to setting a field as `required`.
   *
   * ```proto
   * message MyRepeated {
   *   // value must contain at least  2 items
   *   repeated string value = 1 [(buf.validate.field).repeated.min_items = 2];
   * }
   * ```
   */
  minItems?:
    | string
    | undefined;
  /**
   * `max_items` denotes that this field must not exceed a
   * certain number of items as the upper limit. If the field contains more
   * items than specified, an error message will be generated, requiring the
   * field to maintain no more than the specified number of items.
   *
   * ```proto
   * message MyRepeated {
   *   // value must contain no more than 3 item(s)
   *   repeated string value = 1 [(buf.validate.field).repeated.max_items = 3];
   * }
   * ```
   */
  maxItems?:
    | string
    | undefined;
  /**
   * `unique` indicates that all elements in this field must
   * be unique. This constraint is strictly applicable to scalar and enum
   * types, with message types not being supported.
   *
   * ```proto
   * message MyRepeated {
   *   // repeated value must contain unique items
   *   repeated string value = 1 [(buf.validate.field).repeated.unique = true];
   * }
   * ```
   */
  unique?:
    | boolean
    | undefined;
  /**
   * `items` details the constraints to be applied to each item
   * in the field. Even for repeated message fields, validation is executed
   * against each item unless skip is explicitly specified.
   *
   * ```proto
   * message MyRepeated {
   *   // The items in the field `value` must follow the specified constraints.
   *   repeated string value = 1 [(buf.validate.field).repeated.items = {
   *     string: {
   *       min_len: 3
   *       max_len: 10
   *     }
   *   }];
   * }
   * ```
   */
  items?: FieldConstraints | undefined;
}

/** MapRules describe the constraints applied to `map` values. */
export interface MapRules {
  /**
   * Specifies the minimum number of key-value pairs allowed. If the field has
   * fewer key-value pairs than specified, an error message is generated.
   *
   * ```proto
   * message MyMap {
   *   // The field `value` must have at least 2 key-value pairs.
   *   map<string, string> value = 1 [(buf.validate.field).map.min_pairs = 2];
   * }
   * ```
   */
  minPairs?:
    | string
    | undefined;
  /**
   * Specifies the maximum number of key-value pairs allowed. If the field has
   * more key-value pairs than specified, an error message is generated.
   *
   * ```proto
   * message MyMap {
   *   // The field `value` must have at most 3 key-value pairs.
   *   map<string, string> value = 1 [(buf.validate.field).map.max_pairs = 3];
   * }
   * ```
   */
  maxPairs?:
    | string
    | undefined;
  /**
   * Specifies the constraints to be applied to each key in the field.
   *
   * ```proto
   * message MyMap {
   *   // The keys in the field `value` must follow the specified constraints.
   *   map<string, string> value = 1 [(buf.validate.field).map.keys = {
   *     string: {
   *       min_len: 3
   *       max_len: 10
   *     }
   *   }];
   * }
   * ```
   */
  keys?:
    | FieldConstraints
    | undefined;
  /**
   * Specifies the constraints to be applied to the value of each key in the
   * field. Message values will still have their validations evaluated unless
   * skip is specified here.
   *
   * ```proto
   * message MyMap {
   *   // The values in the field `value` must follow the specified constraints.
   *   map<string, string> value = 1 [(buf.validate.field).map.values = {
   *     string: {
   *       min_len: 5
   *       max_len: 20
   *     }
   *   }];
   * }
   * ```
   */
  values?: FieldConstraints | undefined;
}

/** AnyRules describe constraints applied exclusively to the `google.protobuf.Any` well-known type. */
export interface AnyRules {
  /**
   * `in` requires the field's `type_url` to be equal to one of the
   * specified values. If it doesn't match any of the specified values, an error
   * message is generated.
   *
   * ```proto
   * message MyAny {
   *   //  The `value` field must have a `type_url` equal to one of the specified values.
   *   google.protobuf.Any value = 1 [(buf.validate.field).any.in = ["type.googleapis.com/MyType1", "type.googleapis.com/MyType2"]];
   * }
   * ```
   */
  in?:
    | string[]
    | undefined;
  /**
   * requires the field's type_url to be not equal to any of the specified values. If it matches any of the specified values, an error message is generated.
   *
   * ```proto
   * message MyAny {
   *   // The field `value` must not have a `type_url` equal to any of the specified values.
   *   google.protobuf.Any value = 1 [(buf.validate.field).any.not_in = ["type.googleapis.com/ForbiddenType1", "type.googleapis.com/ForbiddenType2"]];
   * }
   * ```
   */
  notIn?: string[] | undefined;
}

/** DurationRules describe the constraints applied exclusively to the `google.protobuf.Duration` well-known type. */
export interface DurationRules {
  /**
   * `const` dictates that the field must match the specified value of the `google.protobuf.Duration` type exactly.
   * If the field's value deviates from the specified value, an error message
   * will be generated.
   *
   * ```proto
   * message MyDuration {
   *   // value must equal 5s
   *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.const = "5s"];
   * }
   * ```
   */
  const?: Duration | undefined;
  lessThan?:
    | //
    /**
     * `lt` stipulates that the field must be less than the specified value of the `google.protobuf.Duration` type,
     * exclusive. If the field's value is greater than or equal to the specified
     * value, an error message will be generated.
     *
     * ```proto
     * message MyDuration {
     *   // value must be less than 5s
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = "5s"];
     * }
     * ```
     */
    { $case: "lt"; value: Duration }
    | //
    /**
     * `lte` indicates that the field must be less than or equal to the specified
     * value of the `google.protobuf.Duration` type, inclusive. If the field's value is greater than the specified value,
     * an error message will be generated.
     *
     * ```proto
     * message MyDuration {
     *   // value must be less than or equal to 10s
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lte = "10s"];
     * }
     * ```
     */
    { $case: "lte"; value: Duration }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the duration field value to be greater than the specified
     * value (exclusive). If the value of `gt` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyDuration {
     *   // duration must be greater than 5s [duration.gt]
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.gt = { seconds: 5 }];
     *
     *   // duration must be greater than 5s and less than 10s [duration.gt_lt]
     *   google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gt: { seconds: 5 }, lt: { seconds: 10 } }];
     *
     *   // duration must be greater than 10s or less than 5s [duration.gt_lt_exclusive]
     *   google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gt: { seconds: 10 }, lt: { seconds: 5 } }];
     * }
     * ```
     */
    { $case: "gt"; value: Duration }
    | //
    /**
     * `gte` requires the duration field value to be greater than or equal to the
     * specified value (exclusive). If the value of `gte` is larger than a
     * specified `lt` or `lte`, the range is reversed, and the field value must
     * be outside the specified range. If the field value doesn't meet the
     * required conditions, an error message is generated.
     *
     * ```proto
     * message MyDuration {
     *  // duration must be greater than or equal to 5s [duration.gte]
     *  google.protobuf.Duration value = 1 [(buf.validate.field).duration.gte = { seconds: 5 }];
     *
     *  // duration must be greater than or equal to 5s and less than 10s [duration.gte_lt]
     *  google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gte: { seconds: 5 }, lt: { seconds: 10 } }];
     *
     *  // duration must be greater than or equal to 10s or less than 5s [duration.gte_lt_exclusive]
     *  google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gte: { seconds: 10 }, lt: { seconds: 5 } }];
     * }
     * ```
     */
    { $case: "gte"; value: Duration }
    | undefined;
  /**
   * `in` asserts that the field must be equal to one of the specified values of the `google.protobuf.Duration` type.
   * If the field's value doesn't correspond to any of the specified values,
   * an error message will be generated.
   *
   * ```proto
   * message MyDuration {
   *   // value must be in list [1s, 2s, 3s]
   *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.in = ["1s", "2s", "3s"]];
   * }
   * ```
   */
  in?:
    | Duration[]
    | undefined;
  /**
   * `not_in` denotes that the field must not be equal to
   * any of the specified values of the `google.protobuf.Duration` type.
   * If the field's value matches any of these values, an error message will be
   * generated.
   *
   * ```proto
   * message MyDuration {
   *   // value must not be in list [1s, 2s, 3s]
   *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.not_in = ["1s", "2s", "3s"]];
   * }
   * ```
   */
  notIn?:
    | Duration[]
    | undefined;
  /**
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other constraints. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyDuration {
   *   google.protobuf.Duration value = 1 [
   *     (buf.validate.field).duration.example = { seconds: 1 },
   *     (buf.validate.field).duration.example = { seconds: 2 },
   *   ];
   * }
   * ```
   */
  example?: Duration[] | undefined;
}

/** TimestampRules describe the constraints applied exclusively to the `google.protobuf.Timestamp` well-known type. */
export interface TimestampRules {
  /**
   * `const` dictates that this field, of the `google.protobuf.Timestamp` type, must exactly match the specified value. If the field value doesn't correspond to the specified timestamp, an error message will be generated.
   *
   * ```proto
   * message MyTimestamp {
   *   // value must equal 2023-05-03T10:00:00Z
   *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.const = {seconds: 1727998800}];
   * }
   * ```
   */
  const?: Date | undefined;
  lessThan?:
    | //
    /**
     * requires the duration field value to be less than the specified value (field < value). If the field value doesn't meet the required conditions, an error message is generated.
     *
     * ```proto
     * message MyDuration {
     *   // duration must be less than 'P3D' [duration.lt]
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = { seconds: 259200 }];
     * }
     * ```
     */
    { $case: "lt"; value: Date }
    | //
    /**
     * requires the timestamp field value to be less than or equal to the specified value (field <= value). If the field value doesn't meet the required conditions, an error message is generated.
     *
     * ```proto
     * message MyTimestamp {
     *   // timestamp must be less than or equal to '2023-05-14T00:00:00Z' [timestamp.lte]
     *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.lte = { seconds: 1678867200 }];
     * }
     * ```
     */
    { $case: "lte"; value: Date }
    | //
    /**
     * `lt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be less than the current time. `lt_now` can only be used with the `within` rule.
     *
     * ```proto
     * message MyTimestamp {
     *  // value must be less than now
     *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.lt_now = true];
     * }
     * ```
     */
    { $case: "ltNow"; value: boolean }
    | undefined;
  greaterThan?:
    | //
    /**
     * `gt` requires the timestamp field value to be greater than the specified
     * value (exclusive). If the value of `gt` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     *
     * ```proto
     * message MyTimestamp {
     *   // timestamp must be greater than '2023-01-01T00:00:00Z' [timestamp.gt]
     *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gt = { seconds: 1672444800 }];
     *
     *   // timestamp must be greater than '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gt_lt]
     *   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gt: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
     *
     *   // timestamp must be greater than '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gt_lt_exclusive]
     *   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gt: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
     * }
     * ```
     */
    { $case: "gt"; value: Date }
    | //
    /**
     * `gte` requires the timestamp field value to be greater than or equal to the
     * specified value (exclusive). If the value of `gte` is larger than a
     * specified `lt` or `lte`, the range is reversed, and the field value
     * must be outside the specified range. If the field value doesn't meet
     * the required conditions, an error message is generated.
     *
     * ```proto
     * message MyTimestamp {
     *   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' [timestamp.gte]
     *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gte = { seconds: 1672444800 }];
     *
     *   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gte_lt]
     *   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gte: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
     *
     *   // timestamp must be greater than or equal to '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gte_lt_exclusive]
     *   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gte: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
     * }
     * ```
     */
    { $case: "gte"; value: Date }
    | //
    /**
     * `gt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be greater than the current time. `gt_now` can only be used with the `within` rule.
     *
     * ```proto
     * message MyTimestamp {
     *   // value must be greater than now
     *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.gt_now = true];
     * }
     * ```
     */
    { $case: "gtNow"; value: boolean }
    | undefined;
  /**
   * `within` specifies that this field, of the `google.protobuf.Timestamp` type, must be within the specified duration of the current time. If the field value isn't within the duration, an error message is generated.
   *
   * ```proto
   * message MyTimestamp {
   *   // value must be within 1 hour of now
   *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.within = {seconds: 3600}];
   * }
   * ```
   */
  within?: Duration | undefined;
  example?: Date[] | undefined;
}

/**
 * `Violations` is a collection of `Violation` messages. This message type is returned by
 * protovalidate when a proto message fails to meet the requirements set by the `Constraint` validation rules.
 * Each individual violation is represented by a `Violation` message.
 */
export interface Violations {
  /** `violations` is a repeated field that contains all the `Violation` messages corresponding to the violations detected. */
  violations?: Violation[] | undefined;
}

/**
 * `Violation` represents a single instance where a validation rule, expressed
 * as a `Constraint`, was not met. It provides information about the field that
 * caused the violation, the specific constraint that wasn't fulfilled, and a
 * human-readable error message.
 *
 * ```json
 * {
 *   "fieldPath": "bar",
 *   "constraintId": "foo.bar",
 *   "message": "bar must be greater than 0"
 * }
 * ```
 */
export interface Violation {
  /**
   * `field` is a machine-readable path to the field that failed validation.
   * This could be a nested field, in which case the path will include all the parent fields leading to the actual field that caused the violation.
   *
   * For example, consider the following message:
   *
   * ```proto
   * message Message {
   *   bool a = 1 [(buf.validate.field).required = true];
   * }
   * ```
   *
   * It could produce the following violation:
   *
   * ```textproto
   * violation {
   *   field { element { field_number: 1, field_name: "a", field_type: 8 } }
   *   ...
   * }
   * ```
   */
  field?:
    | FieldPath
    | undefined;
  /**
   * `rule` is a machine-readable path that points to the specific constraint rule that failed validation.
   * This will be a nested field starting from the FieldConstraints of the field that failed validation.
   * For custom constraints, this will provide the path of the constraint, e.g. `cel[0]`.
   *
   * For example, consider the following message:
   *
   * ```proto
   * message Message {
   *   bool a = 1 [(buf.validate.field).required = true];
   *   bool b = 2 [(buf.validate.field).cel = {
   *     id: "custom_constraint",
   *     expression: "!this ? 'b must be true': ''"
   *   }]
   * }
   * ```
   *
   * It could produce the following violations:
   *
   * ```textproto
   * violation {
   *   rule { element { field_number: 25, field_name: "required", field_type: 8 } }
   *   ...
   * }
   * violation {
   *   rule { element { field_number: 23, field_name: "cel", field_type: 11, index: 0 } }
   *   ...
   * }
   * ```
   */
  rule?:
    | FieldPath
    | undefined;
  /**
   * `constraint_id` is the unique identifier of the `Constraint` that was not fulfilled.
   * This is the same `id` that was specified in the `Constraint` message, allowing easy tracing of which rule was violated.
   */
  constraintId?:
    | string
    | undefined;
  /**
   * `message` is a human-readable error message that describes the nature of the violation.
   * This can be the default error message from the violated `Constraint`, or it can be a custom message that gives more context about the violation.
   */
  message?:
    | string
    | undefined;
  /** `for_key` indicates whether the violation was caused by a map key, rather than a value. */
  forKey?: boolean | undefined;
}

/**
 * `FieldPath` provides a path to a nested protobuf field.
 *
 * This message provides enough information to render a dotted field path even without protobuf descriptors.
 * It also provides enough information to resolve a nested field through unknown wire data.
 */
export interface FieldPath {
  /** `elements` contains each element of the path, starting from the root and recursing downward. */
  elements?: FieldPathElement[] | undefined;
}

/**
 * `FieldPathElement` provides enough information to nest through a single protobuf field.
 *
 * If the selected field is a map or repeated field, the `subscript` value selects a specific element from it.
 * A path that refers to a value nested under a map key or repeated field index will have a `subscript` value.
 * The `field_type` field allows unambiguous resolution of a field even if descriptors are not available.
 */
export interface FieldPathElement {
  /** `field_number` is the field number this path element refers to. */
  fieldNumber?:
    | number
    | undefined;
  /**
   * `field_name` contains the field name this path element refers to.
   * This can be used to display a human-readable path even if the field number is unknown.
   */
  fieldName?:
    | string
    | undefined;
  /**
   * `field_type` specifies the type of this field. When using reflection, this value is not needed.
   *
   * This value is provided to make it possible to traverse unknown fields through wire data.
   * When traversing wire data, be mindful of both packed[1] and delimited[2] encoding schemes.
   *
   * [1]: https://protobuf.dev/programming-guides/encoding/#packed
   * [2]: https://protobuf.dev/programming-guides/encoding/#groups
   *
   * N.B.: Although groups are deprecated, the corresponding delimited encoding scheme is not, and
   * can be explicitly used in Protocol Buffers 2023 Edition.
   */
  fieldType?:
    | FieldDescriptorProto_Type
    | undefined;
  /**
   * `key_type` specifies the map key type of this field. This value is useful when traversing
   * unknown fields through wire data: specifically, it allows handling the differences between
   * different integer encodings.
   */
  keyType?:
    | FieldDescriptorProto_Type
    | undefined;
  /**
   * `value_type` specifies map value type of this field. This is useful if you want to display a
   * value inside unknown fields through wire data.
   */
  valueType?:
    | FieldDescriptorProto_Type
    | undefined;
  /** `subscript` contains a repeated index or map key, if this path element nests into a repeated or map field. */
  subscript?:
    | //
    /** `index` specifies a 0-based index into a repeated field. */
    { $case: "index"; value: string }
    | //
    /** `bool_key` specifies a map key of type bool. */
    { $case: "boolKey"; value: boolean }
    | //
    /** `int_key` specifies a map key of type int32, int64, sint32, sint64, sfixed32 or sfixed64. */
    { $case: "intKey"; value: string }
    | //
    /** `uint_key` specifies a map key of type uint32, uint64, fixed32 or fixed64. */
    { $case: "uintKey"; value: string }
    | //
    /** `string_key` specifies a map key of type string. */
    { $case: "stringKey"; value: string }
    | undefined;
}

function createBaseConstraint(): Constraint {
  return { id: "", message: "", expression: "" };
}

export const Constraint: MessageFns<Constraint> = {
  encode(message: Constraint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined && message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.expression !== undefined && message.expression !== "") {
      writer.uint32(26).string(message.expression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Constraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expression = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Constraint {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
    };
  },

  toJSON(message: Constraint): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== "") {
      obj.id = message.id;
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.expression !== undefined && message.expression !== "") {
      obj.expression = message.expression;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Constraint>, I>>(base?: I): Constraint {
    return Constraint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Constraint>, I>>(object: I): Constraint {
    const message = createBaseConstraint();
    message.id = object.id ?? "";
    message.message = object.message ?? "";
    message.expression = object.expression ?? "";
    return message;
  },
};

function createBaseMessageConstraints(): MessageConstraints {
  return { disabled: false, cel: [] };
}

export const MessageConstraints: MessageFns<MessageConstraints> = {
  encode(message: MessageConstraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== undefined && message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    if (message.cel !== undefined && message.cel.length !== 0) {
      for (const v of message.cel) {
        Constraint.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageConstraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = Constraint.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.cel!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageConstraints {
    return {
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      cel: globalThis.Array.isArray(object?.cel) ? object.cel.map((e: any) => Constraint.fromJSON(e)) : [],
    };
  },

  toJSON(message: MessageConstraints): unknown {
    const obj: any = {};
    if (message.disabled !== undefined && message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.cel?.length) {
      obj.cel = message.cel.map((e) => Constraint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageConstraints>, I>>(base?: I): MessageConstraints {
    return MessageConstraints.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageConstraints>, I>>(object: I): MessageConstraints {
    const message = createBaseMessageConstraints();
    message.disabled = object.disabled ?? false;
    message.cel = object.cel?.map((e) => Constraint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOneofConstraints(): OneofConstraints {
  return { required: false };
}

export const OneofConstraints: MessageFns<OneofConstraints> = {
  encode(message: OneofConstraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.required !== undefined && message.required !== false) {
      writer.uint32(8).bool(message.required);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OneofConstraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOneofConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OneofConstraints {
    return { required: isSet(object.required) ? globalThis.Boolean(object.required) : false };
  },

  toJSON(message: OneofConstraints): unknown {
    const obj: any = {};
    if (message.required !== undefined && message.required !== false) {
      obj.required = message.required;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OneofConstraints>, I>>(base?: I): OneofConstraints {
    return OneofConstraints.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OneofConstraints>, I>>(object: I): OneofConstraints {
    const message = createBaseOneofConstraints();
    message.required = object.required ?? false;
    return message;
  },
};

function createBaseFieldConstraints(): FieldConstraints {
  return { cel: [], required: false, ignore: 0, type: undefined };
}

export const FieldConstraints: MessageFns<FieldConstraints> = {
  encode(message: FieldConstraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cel !== undefined && message.cel.length !== 0) {
      for (const v of message.cel) {
        Constraint.encode(v!, writer.uint32(186).fork()).join();
      }
    }
    if (message.required !== undefined && message.required !== false) {
      writer.uint32(200).bool(message.required);
    }
    if (message.ignore !== undefined && message.ignore !== 0) {
      writer.uint32(216).int32(message.ignore);
    }
    switch (message.type?.$case) {
      case "float":
        FloatRules.encode(message.type.value, writer.uint32(10).fork()).join();
        break;
      case "double":
        DoubleRules.encode(message.type.value, writer.uint32(18).fork()).join();
        break;
      case "int32":
        Int32Rules.encode(message.type.value, writer.uint32(26).fork()).join();
        break;
      case "int64":
        Int64Rules.encode(message.type.value, writer.uint32(34).fork()).join();
        break;
      case "uint32":
        UInt32Rules.encode(message.type.value, writer.uint32(42).fork()).join();
        break;
      case "uint64":
        UInt64Rules.encode(message.type.value, writer.uint32(50).fork()).join();
        break;
      case "sint32":
        SInt32Rules.encode(message.type.value, writer.uint32(58).fork()).join();
        break;
      case "sint64":
        SInt64Rules.encode(message.type.value, writer.uint32(66).fork()).join();
        break;
      case "fixed32":
        Fixed32Rules.encode(message.type.value, writer.uint32(74).fork()).join();
        break;
      case "fixed64":
        Fixed64Rules.encode(message.type.value, writer.uint32(82).fork()).join();
        break;
      case "sfixed32":
        SFixed32Rules.encode(message.type.value, writer.uint32(90).fork()).join();
        break;
      case "sfixed64":
        SFixed64Rules.encode(message.type.value, writer.uint32(98).fork()).join();
        break;
      case "bool":
        BoolRules.encode(message.type.value, writer.uint32(106).fork()).join();
        break;
      case "string":
        StringRules.encode(message.type.value, writer.uint32(114).fork()).join();
        break;
      case "bytes":
        BytesRules.encode(message.type.value, writer.uint32(122).fork()).join();
        break;
      case "enum":
        EnumRules.encode(message.type.value, writer.uint32(130).fork()).join();
        break;
      case "repeated":
        RepeatedRules.encode(message.type.value, writer.uint32(146).fork()).join();
        break;
      case "map":
        MapRules.encode(message.type.value, writer.uint32(154).fork()).join();
        break;
      case "any":
        AnyRules.encode(message.type.value, writer.uint32(162).fork()).join();
        break;
      case "duration":
        DurationRules.encode(message.type.value, writer.uint32(170).fork()).join();
        break;
      case "timestamp":
        TimestampRules.encode(message.type.value, writer.uint32(178).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldConstraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 23: {
          if (tag !== 186) {
            break;
          }

          const el = Constraint.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.cel!.push(el);
          }
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.ignore = reader.int32() as any;
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = { $case: "float", value: FloatRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = { $case: "double", value: DoubleRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = { $case: "int32", value: Int32Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = { $case: "int64", value: Int64Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = { $case: "uint32", value: UInt32Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = { $case: "uint64", value: UInt64Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = { $case: "sint32", value: SInt32Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.type = { $case: "sint64", value: SInt64Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.type = { $case: "fixed32", value: Fixed32Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.type = { $case: "fixed64", value: Fixed64Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.type = { $case: "sfixed32", value: SFixed32Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.type = { $case: "sfixed64", value: SFixed64Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.type = { $case: "bool", value: BoolRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.type = { $case: "string", value: StringRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.type = { $case: "bytes", value: BytesRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.type = { $case: "enum", value: EnumRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.type = { $case: "repeated", value: RepeatedRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.type = { $case: "map", value: MapRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.type = { $case: "any", value: AnyRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.type = { $case: "duration", value: DurationRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.type = { $case: "timestamp", value: TimestampRules.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldConstraints {
    return {
      cel: globalThis.Array.isArray(object?.cel) ? object.cel.map((e: any) => Constraint.fromJSON(e)) : [],
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      ignore: isSet(object.ignore) ? ignoreFromJSON(object.ignore) : 0,
      type: isSet(object.float)
        ? { $case: "float", value: FloatRules.fromJSON(object.float) }
        : isSet(object.double)
        ? { $case: "double", value: DoubleRules.fromJSON(object.double) }
        : isSet(object.int32)
        ? { $case: "int32", value: Int32Rules.fromJSON(object.int32) }
        : isSet(object.int64)
        ? { $case: "int64", value: Int64Rules.fromJSON(object.int64) }
        : isSet(object.uint32)
        ? { $case: "uint32", value: UInt32Rules.fromJSON(object.uint32) }
        : isSet(object.uint64)
        ? { $case: "uint64", value: UInt64Rules.fromJSON(object.uint64) }
        : isSet(object.sint32)
        ? { $case: "sint32", value: SInt32Rules.fromJSON(object.sint32) }
        : isSet(object.sint64)
        ? { $case: "sint64", value: SInt64Rules.fromJSON(object.sint64) }
        : isSet(object.fixed32)
        ? { $case: "fixed32", value: Fixed32Rules.fromJSON(object.fixed32) }
        : isSet(object.fixed64)
        ? { $case: "fixed64", value: Fixed64Rules.fromJSON(object.fixed64) }
        : isSet(object.sfixed32)
        ? { $case: "sfixed32", value: SFixed32Rules.fromJSON(object.sfixed32) }
        : isSet(object.sfixed64)
        ? { $case: "sfixed64", value: SFixed64Rules.fromJSON(object.sfixed64) }
        : isSet(object.bool)
        ? { $case: "bool", value: BoolRules.fromJSON(object.bool) }
        : isSet(object.string)
        ? { $case: "string", value: StringRules.fromJSON(object.string) }
        : isSet(object.bytes)
        ? { $case: "bytes", value: BytesRules.fromJSON(object.bytes) }
        : isSet(object.enum)
        ? { $case: "enum", value: EnumRules.fromJSON(object.enum) }
        : isSet(object.repeated)
        ? { $case: "repeated", value: RepeatedRules.fromJSON(object.repeated) }
        : isSet(object.map)
        ? { $case: "map", value: MapRules.fromJSON(object.map) }
        : isSet(object.any)
        ? { $case: "any", value: AnyRules.fromJSON(object.any) }
        : isSet(object.duration)
        ? { $case: "duration", value: DurationRules.fromJSON(object.duration) }
        : isSet(object.timestamp)
        ? { $case: "timestamp", value: TimestampRules.fromJSON(object.timestamp) }
        : undefined,
    };
  },

  toJSON(message: FieldConstraints): unknown {
    const obj: any = {};
    if (message.cel?.length) {
      obj.cel = message.cel.map((e) => Constraint.toJSON(e));
    }
    if (message.required !== undefined && message.required !== false) {
      obj.required = message.required;
    }
    if (message.ignore !== undefined && message.ignore !== 0) {
      obj.ignore = ignoreToJSON(message.ignore);
    }
    if (message.type?.$case === "float") {
      obj.float = FloatRules.toJSON(message.type.value);
    } else if (message.type?.$case === "double") {
      obj.double = DoubleRules.toJSON(message.type.value);
    } else if (message.type?.$case === "int32") {
      obj.int32 = Int32Rules.toJSON(message.type.value);
    } else if (message.type?.$case === "int64") {
      obj.int64 = Int64Rules.toJSON(message.type.value);
    } else if (message.type?.$case === "uint32") {
      obj.uint32 = UInt32Rules.toJSON(message.type.value);
    } else if (message.type?.$case === "uint64") {
      obj.uint64 = UInt64Rules.toJSON(message.type.value);
    } else if (message.type?.$case === "sint32") {
      obj.sint32 = SInt32Rules.toJSON(message.type.value);
    } else if (message.type?.$case === "sint64") {
      obj.sint64 = SInt64Rules.toJSON(message.type.value);
    } else if (message.type?.$case === "fixed32") {
      obj.fixed32 = Fixed32Rules.toJSON(message.type.value);
    } else if (message.type?.$case === "fixed64") {
      obj.fixed64 = Fixed64Rules.toJSON(message.type.value);
    } else if (message.type?.$case === "sfixed32") {
      obj.sfixed32 = SFixed32Rules.toJSON(message.type.value);
    } else if (message.type?.$case === "sfixed64") {
      obj.sfixed64 = SFixed64Rules.toJSON(message.type.value);
    } else if (message.type?.$case === "bool") {
      obj.bool = BoolRules.toJSON(message.type.value);
    } else if (message.type?.$case === "string") {
      obj.string = StringRules.toJSON(message.type.value);
    } else if (message.type?.$case === "bytes") {
      obj.bytes = BytesRules.toJSON(message.type.value);
    } else if (message.type?.$case === "enum") {
      obj.enum = EnumRules.toJSON(message.type.value);
    } else if (message.type?.$case === "repeated") {
      obj.repeated = RepeatedRules.toJSON(message.type.value);
    } else if (message.type?.$case === "map") {
      obj.map = MapRules.toJSON(message.type.value);
    } else if (message.type?.$case === "any") {
      obj.any = AnyRules.toJSON(message.type.value);
    } else if (message.type?.$case === "duration") {
      obj.duration = DurationRules.toJSON(message.type.value);
    } else if (message.type?.$case === "timestamp") {
      obj.timestamp = TimestampRules.toJSON(message.type.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldConstraints>, I>>(base?: I): FieldConstraints {
    return FieldConstraints.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldConstraints>, I>>(object: I): FieldConstraints {
    const message = createBaseFieldConstraints();
    message.cel = object.cel?.map((e) => Constraint.fromPartial(e)) || [];
    message.required = object.required ?? false;
    message.ignore = object.ignore ?? 0;
    switch (object.type?.$case) {
      case "float": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "float", value: FloatRules.fromPartial(object.type.value) };
        }
        break;
      }
      case "double": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "double", value: DoubleRules.fromPartial(object.type.value) };
        }
        break;
      }
      case "int32": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "int32", value: Int32Rules.fromPartial(object.type.value) };
        }
        break;
      }
      case "int64": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "int64", value: Int64Rules.fromPartial(object.type.value) };
        }
        break;
      }
      case "uint32": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "uint32", value: UInt32Rules.fromPartial(object.type.value) };
        }
        break;
      }
      case "uint64": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "uint64", value: UInt64Rules.fromPartial(object.type.value) };
        }
        break;
      }
      case "sint32": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "sint32", value: SInt32Rules.fromPartial(object.type.value) };
        }
        break;
      }
      case "sint64": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "sint64", value: SInt64Rules.fromPartial(object.type.value) };
        }
        break;
      }
      case "fixed32": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "fixed32", value: Fixed32Rules.fromPartial(object.type.value) };
        }
        break;
      }
      case "fixed64": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "fixed64", value: Fixed64Rules.fromPartial(object.type.value) };
        }
        break;
      }
      case "sfixed32": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "sfixed32", value: SFixed32Rules.fromPartial(object.type.value) };
        }
        break;
      }
      case "sfixed64": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "sfixed64", value: SFixed64Rules.fromPartial(object.type.value) };
        }
        break;
      }
      case "bool": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "bool", value: BoolRules.fromPartial(object.type.value) };
        }
        break;
      }
      case "string": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "string", value: StringRules.fromPartial(object.type.value) };
        }
        break;
      }
      case "bytes": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "bytes", value: BytesRules.fromPartial(object.type.value) };
        }
        break;
      }
      case "enum": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "enum", value: EnumRules.fromPartial(object.type.value) };
        }
        break;
      }
      case "repeated": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "repeated", value: RepeatedRules.fromPartial(object.type.value) };
        }
        break;
      }
      case "map": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "map", value: MapRules.fromPartial(object.type.value) };
        }
        break;
      }
      case "any": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "any", value: AnyRules.fromPartial(object.type.value) };
        }
        break;
      }
      case "duration": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "duration", value: DurationRules.fromPartial(object.type.value) };
        }
        break;
      }
      case "timestamp": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "timestamp", value: TimestampRules.fromPartial(object.type.value) };
        }
        break;
      }
    }
    return message;
  },
};

function createBasePredefinedConstraints(): PredefinedConstraints {
  return { cel: [] };
}

export const PredefinedConstraints: MessageFns<PredefinedConstraints> = {
  encode(message: PredefinedConstraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cel !== undefined && message.cel.length !== 0) {
      for (const v of message.cel) {
        Constraint.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PredefinedConstraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePredefinedConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = Constraint.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.cel!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PredefinedConstraints {
    return { cel: globalThis.Array.isArray(object?.cel) ? object.cel.map((e: any) => Constraint.fromJSON(e)) : [] };
  },

  toJSON(message: PredefinedConstraints): unknown {
    const obj: any = {};
    if (message.cel?.length) {
      obj.cel = message.cel.map((e) => Constraint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PredefinedConstraints>, I>>(base?: I): PredefinedConstraints {
    return PredefinedConstraints.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PredefinedConstraints>, I>>(object: I): PredefinedConstraints {
    const message = createBasePredefinedConstraints();
    message.cel = object.cel?.map((e) => Constraint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFloatRules(): FloatRules {
  return { const: 0, lessThan: undefined, greaterThan: undefined, in: [], notIn: [], finite: false, example: [] };
}

export const FloatRules: MessageFns<FloatRules> = {
  encode(message: FloatRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(13).float(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(21).float(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(29).float(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(37).float(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(45).float(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(53).float(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(61).float(v!);
      }
    }
    if (message.finite !== undefined && message.finite !== false) {
      writer.uint32(64).bool(message.finite);
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(77).float(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.const = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.float() };
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.float() };
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.float() };
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.float() };
          continue;
        }
        case 6: {
          if (tag === 53) {
            message.in!.push(reader.float());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 61) {
            message.notIn!.push(reader.float());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.finite = reader.bool();
          continue;
        }
        case 9: {
          if (tag === 77) {
            message.example!.push(reader.float());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatRules {
    return {
      const: isSet(object.const) ? globalThis.Number(object.const) : 0,
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.Number(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.Number(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.Number(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.Number(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.Number(e)) : [],
      finite: isSet(object.finite) ? globalThis.Boolean(object.finite) : false,
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: FloatRules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== 0) {
      obj.const = message.const;
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = message.lessThan.value;
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = message.lessThan.value;
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = message.greaterThan.value;
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = message.greaterThan.value;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn;
    }
    if (message.finite !== undefined && message.finite !== false) {
      obj.finite = message.finite;
    }
    if (message.example?.length) {
      obj.example = message.example;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FloatRules>, I>>(base?: I): FloatRules {
    return FloatRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FloatRules>, I>>(object: I): FloatRules {
    const message = createBaseFloatRules();
    message.const = object.const ?? 0;
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.finite = object.finite ?? false;
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseDoubleRules(): DoubleRules {
  return { const: 0, lessThan: undefined, greaterThan: undefined, in: [], notIn: [], finite: false, example: [] };
}

export const DoubleRules: MessageFns<DoubleRules> = {
  encode(message: DoubleRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(9).double(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(17).double(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(25).double(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(33).double(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(41).double(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(49).double(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(57).double(v!);
      }
    }
    if (message.finite !== undefined && message.finite !== false) {
      writer.uint32(64).bool(message.finite);
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(73).double(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.const = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.double() };
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.double() };
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.double() };
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.double() };
          continue;
        }
        case 6: {
          if (tag === 49) {
            message.in!.push(reader.double());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 57) {
            message.notIn!.push(reader.double());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.finite = reader.bool();
          continue;
        }
        case 9: {
          if (tag === 73) {
            message.example!.push(reader.double());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.double());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleRules {
    return {
      const: isSet(object.const) ? globalThis.Number(object.const) : 0,
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.Number(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.Number(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.Number(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.Number(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.Number(e)) : [],
      finite: isSet(object.finite) ? globalThis.Boolean(object.finite) : false,
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: DoubleRules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== 0) {
      obj.const = message.const;
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = message.lessThan.value;
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = message.lessThan.value;
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = message.greaterThan.value;
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = message.greaterThan.value;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn;
    }
    if (message.finite !== undefined && message.finite !== false) {
      obj.finite = message.finite;
    }
    if (message.example?.length) {
      obj.example = message.example;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DoubleRules>, I>>(base?: I): DoubleRules {
    return DoubleRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DoubleRules>, I>>(object: I): DoubleRules {
    const message = createBaseDoubleRules();
    message.const = object.const ?? 0;
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.finite = object.finite ?? false;
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseInt32Rules(): Int32Rules {
  return { const: 0, lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const Int32Rules: MessageFns<Int32Rules> = {
  encode(message: Int32Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).int32(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(16).int32(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(24).int32(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(32).int32(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(40).int32(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(48).int32(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(56).int32(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(64).int32(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.int32() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.int32() };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.int32() };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.int32() };
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.in!.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            message.notIn!.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 64) {
            message.example!.push(reader.int32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32Rules {
    return {
      const: isSet(object.const) ? globalThis.Number(object.const) : 0,
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.Number(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.Number(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.Number(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.Number(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.Number(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: Int32Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== 0) {
      obj.const = Math.round(message.const);
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = Math.round(message.lessThan.value);
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = Math.round(message.lessThan.value);
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = Math.round(message.greaterThan.value);
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = Math.round(message.greaterThan.value);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn.map((e) => Math.round(e));
    }
    if (message.example?.length) {
      obj.example = message.example.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Int32Rules>, I>>(base?: I): Int32Rules {
    return Int32Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Int32Rules>, I>>(object: I): Int32Rules {
    const message = createBaseInt32Rules();
    message.const = object.const ?? 0;
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseInt64Rules(): Int64Rules {
  return { const: "0", lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const Int64Rules: MessageFns<Int64Rules> = {
  encode(message: Int64Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== "0") {
      writer.uint32(8).int64(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(16).int64(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(24).int64(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(32).int64(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(40).int64(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(48).int64(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(56).int64(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(72).int64(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.int64().toString() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.int64().toString() };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.int64().toString() };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.int64().toString() };
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.in!.push(reader.int64().toString());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            message.notIn!.push(reader.int64().toString());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag === 72) {
            message.example!.push(reader.int64().toString());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64Rules {
    return {
      const: isSet(object.const) ? globalThis.String(object.const) : "0",
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.String(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.String(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.String(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.String(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.String(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.String(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Int64Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== "0") {
      obj.const = message.const;
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = message.lessThan.value;
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = message.lessThan.value;
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = message.greaterThan.value;
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = message.greaterThan.value;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn;
    }
    if (message.example?.length) {
      obj.example = message.example;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Int64Rules>, I>>(base?: I): Int64Rules {
    return Int64Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Int64Rules>, I>>(object: I): Int64Rules {
    const message = createBaseInt64Rules();
    message.const = object.const ?? "0";
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseUInt32Rules(): UInt32Rules {
  return { const: 0, lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const UInt32Rules: MessageFns<UInt32Rules> = {
  encode(message: UInt32Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).uint32(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(16).uint32(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(24).uint32(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(32).uint32(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(40).uint32(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(48).uint32(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(56).uint32(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(64).uint32(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.uint32() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.uint32() };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.uint32() };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.uint32() };
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.in!.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            message.notIn!.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 64) {
            message.example!.push(reader.uint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32Rules {
    return {
      const: isSet(object.const) ? globalThis.Number(object.const) : 0,
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.Number(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.Number(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.Number(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.Number(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.Number(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: UInt32Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== 0) {
      obj.const = Math.round(message.const);
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = Math.round(message.lessThan.value);
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = Math.round(message.lessThan.value);
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = Math.round(message.greaterThan.value);
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = Math.round(message.greaterThan.value);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn.map((e) => Math.round(e));
    }
    if (message.example?.length) {
      obj.example = message.example.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UInt32Rules>, I>>(base?: I): UInt32Rules {
    return UInt32Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UInt32Rules>, I>>(object: I): UInt32Rules {
    const message = createBaseUInt32Rules();
    message.const = object.const ?? 0;
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseUInt64Rules(): UInt64Rules {
  return { const: "0", lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const UInt64Rules: MessageFns<UInt64Rules> = {
  encode(message: UInt64Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== "0") {
      writer.uint32(8).uint64(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(16).uint64(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(24).uint64(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(32).uint64(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(40).uint64(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(48).uint64(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(56).uint64(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(64).uint64(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.uint64().toString() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.uint64().toString() };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.uint64().toString() };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.uint64().toString() };
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.in!.push(reader.uint64().toString());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            message.notIn!.push(reader.uint64().toString());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 64) {
            message.example!.push(reader.uint64().toString());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64Rules {
    return {
      const: isSet(object.const) ? globalThis.String(object.const) : "0",
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.String(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.String(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.String(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.String(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.String(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.String(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UInt64Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== "0") {
      obj.const = message.const;
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = message.lessThan.value;
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = message.lessThan.value;
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = message.greaterThan.value;
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = message.greaterThan.value;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn;
    }
    if (message.example?.length) {
      obj.example = message.example;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UInt64Rules>, I>>(base?: I): UInt64Rules {
    return UInt64Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UInt64Rules>, I>>(object: I): UInt64Rules {
    const message = createBaseUInt64Rules();
    message.const = object.const ?? "0";
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseSInt32Rules(): SInt32Rules {
  return { const: 0, lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const SInt32Rules: MessageFns<SInt32Rules> = {
  encode(message: SInt32Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).sint32(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(16).sint32(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(24).sint32(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(32).sint32(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(40).sint32(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(48).sint32(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(56).sint32(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(64).sint32(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.sint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.sint32() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.sint32() };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.sint32() };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.sint32() };
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.in!.push(reader.sint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.sint32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            message.notIn!.push(reader.sint32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.sint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 64) {
            message.example!.push(reader.sint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.sint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32Rules {
    return {
      const: isSet(object.const) ? globalThis.Number(object.const) : 0,
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.Number(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.Number(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.Number(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.Number(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.Number(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: SInt32Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== 0) {
      obj.const = Math.round(message.const);
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = Math.round(message.lessThan.value);
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = Math.round(message.lessThan.value);
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = Math.round(message.greaterThan.value);
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = Math.round(message.greaterThan.value);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn.map((e) => Math.round(e));
    }
    if (message.example?.length) {
      obj.example = message.example.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SInt32Rules>, I>>(base?: I): SInt32Rules {
    return SInt32Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SInt32Rules>, I>>(object: I): SInt32Rules {
    const message = createBaseSInt32Rules();
    message.const = object.const ?? 0;
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseSInt64Rules(): SInt64Rules {
  return { const: "0", lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const SInt64Rules: MessageFns<SInt64Rules> = {
  encode(message: SInt64Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== "0") {
      writer.uint32(8).sint64(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(16).sint64(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(24).sint64(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(32).sint64(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(40).sint64(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(48).sint64(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(56).sint64(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(64).sint64(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.sint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.sint64().toString() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.sint64().toString() };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.sint64().toString() };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.sint64().toString() };
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.in!.push(reader.sint64().toString());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.sint64().toString());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            message.notIn!.push(reader.sint64().toString());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.sint64().toString());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 64) {
            message.example!.push(reader.sint64().toString());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.sint64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64Rules {
    return {
      const: isSet(object.const) ? globalThis.String(object.const) : "0",
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.String(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.String(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.String(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.String(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.String(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.String(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: SInt64Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== "0") {
      obj.const = message.const;
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = message.lessThan.value;
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = message.lessThan.value;
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = message.greaterThan.value;
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = message.greaterThan.value;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn;
    }
    if (message.example?.length) {
      obj.example = message.example;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SInt64Rules>, I>>(base?: I): SInt64Rules {
    return SInt64Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SInt64Rules>, I>>(object: I): SInt64Rules {
    const message = createBaseSInt64Rules();
    message.const = object.const ?? "0";
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseFixed32Rules(): Fixed32Rules {
  return { const: 0, lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const Fixed32Rules: MessageFns<Fixed32Rules> = {
  encode(message: Fixed32Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(13).fixed32(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(21).fixed32(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(29).fixed32(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(37).fixed32(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(45).fixed32(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(53).fixed32(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(61).fixed32(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(69).fixed32(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.const = reader.fixed32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.fixed32() };
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.fixed32() };
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.fixed32() };
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.fixed32() };
          continue;
        }
        case 6: {
          if (tag === 53) {
            message.in!.push(reader.fixed32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.fixed32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 61) {
            message.notIn!.push(reader.fixed32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.fixed32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 69) {
            message.example!.push(reader.fixed32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.fixed32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32Rules {
    return {
      const: isSet(object.const) ? globalThis.Number(object.const) : 0,
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.Number(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.Number(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.Number(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.Number(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.Number(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: Fixed32Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== 0) {
      obj.const = Math.round(message.const);
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = Math.round(message.lessThan.value);
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = Math.round(message.lessThan.value);
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = Math.round(message.greaterThan.value);
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = Math.round(message.greaterThan.value);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn.map((e) => Math.round(e));
    }
    if (message.example?.length) {
      obj.example = message.example.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fixed32Rules>, I>>(base?: I): Fixed32Rules {
    return Fixed32Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fixed32Rules>, I>>(object: I): Fixed32Rules {
    const message = createBaseFixed32Rules();
    message.const = object.const ?? 0;
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseFixed64Rules(): Fixed64Rules {
  return { const: "0", lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const Fixed64Rules: MessageFns<Fixed64Rules> = {
  encode(message: Fixed64Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== "0") {
      writer.uint32(9).fixed64(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(17).fixed64(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(25).fixed64(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(33).fixed64(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(41).fixed64(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(49).fixed64(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(57).fixed64(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(65).fixed64(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.const = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.fixed64().toString() };
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.fixed64().toString() };
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.fixed64().toString() };
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.fixed64().toString() };
          continue;
        }
        case 6: {
          if (tag === 49) {
            message.in!.push(reader.fixed64().toString());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.fixed64().toString());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 57) {
            message.notIn!.push(reader.fixed64().toString());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.fixed64().toString());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 65) {
            message.example!.push(reader.fixed64().toString());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.fixed64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64Rules {
    return {
      const: isSet(object.const) ? globalThis.String(object.const) : "0",
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.String(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.String(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.String(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.String(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.String(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.String(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Fixed64Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== "0") {
      obj.const = message.const;
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = message.lessThan.value;
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = message.lessThan.value;
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = message.greaterThan.value;
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = message.greaterThan.value;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn;
    }
    if (message.example?.length) {
      obj.example = message.example;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fixed64Rules>, I>>(base?: I): Fixed64Rules {
    return Fixed64Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fixed64Rules>, I>>(object: I): Fixed64Rules {
    const message = createBaseFixed64Rules();
    message.const = object.const ?? "0";
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseSFixed32Rules(): SFixed32Rules {
  return { const: 0, lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const SFixed32Rules: MessageFns<SFixed32Rules> = {
  encode(message: SFixed32Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(13).sfixed32(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(21).sfixed32(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(29).sfixed32(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(37).sfixed32(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(45).sfixed32(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(53).sfixed32(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(61).sfixed32(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(69).sfixed32(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.const = reader.sfixed32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.sfixed32() };
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.sfixed32() };
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.sfixed32() };
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.sfixed32() };
          continue;
        }
        case 6: {
          if (tag === 53) {
            message.in!.push(reader.sfixed32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.sfixed32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 61) {
            message.notIn!.push(reader.sfixed32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.sfixed32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 69) {
            message.example!.push(reader.sfixed32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.sfixed32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32Rules {
    return {
      const: isSet(object.const) ? globalThis.Number(object.const) : 0,
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.Number(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.Number(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.Number(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.Number(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.Number(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: SFixed32Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== 0) {
      obj.const = Math.round(message.const);
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = Math.round(message.lessThan.value);
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = Math.round(message.lessThan.value);
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = Math.round(message.greaterThan.value);
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = Math.round(message.greaterThan.value);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn.map((e) => Math.round(e));
    }
    if (message.example?.length) {
      obj.example = message.example.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SFixed32Rules>, I>>(base?: I): SFixed32Rules {
    return SFixed32Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SFixed32Rules>, I>>(object: I): SFixed32Rules {
    const message = createBaseSFixed32Rules();
    message.const = object.const ?? 0;
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseSFixed64Rules(): SFixed64Rules {
  return { const: "0", lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const SFixed64Rules: MessageFns<SFixed64Rules> = {
  encode(message: SFixed64Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== "0") {
      writer.uint32(9).sfixed64(message.const);
    }
    switch (message.lessThan?.$case) {
      case "lt":
        writer.uint32(17).sfixed64(message.lessThan.value);
        break;
      case "lte":
        writer.uint32(25).sfixed64(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        writer.uint32(33).sfixed64(message.greaterThan.value);
        break;
      case "gte":
        writer.uint32(41).sfixed64(message.greaterThan.value);
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(49).sfixed64(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(57).sfixed64(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(65).sfixed64(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.const = reader.sfixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.lessThan = { $case: "lt", value: reader.sfixed64().toString() };
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.lessThan = { $case: "lte", value: reader.sfixed64().toString() };
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.greaterThan = { $case: "gt", value: reader.sfixed64().toString() };
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.greaterThan = { $case: "gte", value: reader.sfixed64().toString() };
          continue;
        }
        case 6: {
          if (tag === 49) {
            message.in!.push(reader.sfixed64().toString());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.sfixed64().toString());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 57) {
            message.notIn!.push(reader.sfixed64().toString());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.sfixed64().toString());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 65) {
            message.example!.push(reader.sfixed64().toString());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.sfixed64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64Rules {
    return {
      const: isSet(object.const) ? globalThis.String(object.const) : "0",
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: globalThis.String(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: globalThis.String(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: globalThis.String(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: globalThis.String(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.String(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.String(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: SFixed64Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== "0") {
      obj.const = message.const;
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = message.lessThan.value;
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = message.lessThan.value;
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = message.greaterThan.value;
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = message.greaterThan.value;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn;
    }
    if (message.example?.length) {
      obj.example = message.example;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SFixed64Rules>, I>>(base?: I): SFixed64Rules {
    return SFixed64Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SFixed64Rules>, I>>(object: I): SFixed64Rules {
    const message = createBaseSFixed64Rules();
    message.const = object.const ?? "0";
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseBoolRules(): BoolRules {
  return { const: false, example: [] };
}

export const BoolRules: MessageFns<BoolRules> = {
  encode(message: BoolRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== false) {
      writer.uint32(8).bool(message.const);
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(16).bool(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoolRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoolRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.bool();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.example!.push(reader.bool());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.bool());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoolRules {
    return {
      const: isSet(object.const) ? globalThis.Boolean(object.const) : false,
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.Boolean(e)) : [],
    };
  },

  toJSON(message: BoolRules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== false) {
      obj.const = message.const;
    }
    if (message.example?.length) {
      obj.example = message.example;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BoolRules>, I>>(base?: I): BoolRules {
    return BoolRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BoolRules>, I>>(object: I): BoolRules {
    const message = createBaseBoolRules();
    message.const = object.const ?? false;
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseStringRules(): StringRules {
  return {
    const: "",
    len: "0",
    minLen: "0",
    maxLen: "0",
    lenBytes: "0",
    minBytes: "0",
    maxBytes: "0",
    pattern: "",
    prefix: "",
    suffix: "",
    contains: "",
    notContains: "",
    in: [],
    notIn: [],
    wellKnown: undefined,
    strict: false,
    example: [],
  };
}

export const StringRules: MessageFns<StringRules> = {
  encode(message: StringRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== "") {
      writer.uint32(10).string(message.const);
    }
    if (message.len !== undefined && message.len !== "0") {
      writer.uint32(152).uint64(message.len);
    }
    if (message.minLen !== undefined && message.minLen !== "0") {
      writer.uint32(16).uint64(message.minLen);
    }
    if (message.maxLen !== undefined && message.maxLen !== "0") {
      writer.uint32(24).uint64(message.maxLen);
    }
    if (message.lenBytes !== undefined && message.lenBytes !== "0") {
      writer.uint32(160).uint64(message.lenBytes);
    }
    if (message.minBytes !== undefined && message.minBytes !== "0") {
      writer.uint32(32).uint64(message.minBytes);
    }
    if (message.maxBytes !== undefined && message.maxBytes !== "0") {
      writer.uint32(40).uint64(message.maxBytes);
    }
    if (message.pattern !== undefined && message.pattern !== "") {
      writer.uint32(50).string(message.pattern);
    }
    if (message.prefix !== undefined && message.prefix !== "") {
      writer.uint32(58).string(message.prefix);
    }
    if (message.suffix !== undefined && message.suffix !== "") {
      writer.uint32(66).string(message.suffix);
    }
    if (message.contains !== undefined && message.contains !== "") {
      writer.uint32(74).string(message.contains);
    }
    if (message.notContains !== undefined && message.notContains !== "") {
      writer.uint32(186).string(message.notContains);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(82).string(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(90).string(v!);
      }
    }
    switch (message.wellKnown?.$case) {
      case "email":
        writer.uint32(96).bool(message.wellKnown.value);
        break;
      case "hostname":
        writer.uint32(104).bool(message.wellKnown.value);
        break;
      case "ip":
        writer.uint32(112).bool(message.wellKnown.value);
        break;
      case "ipv4":
        writer.uint32(120).bool(message.wellKnown.value);
        break;
      case "ipv6":
        writer.uint32(128).bool(message.wellKnown.value);
        break;
      case "uri":
        writer.uint32(136).bool(message.wellKnown.value);
        break;
      case "uriRef":
        writer.uint32(144).bool(message.wellKnown.value);
        break;
      case "address":
        writer.uint32(168).bool(message.wellKnown.value);
        break;
      case "uuid":
        writer.uint32(176).bool(message.wellKnown.value);
        break;
      case "tuuid":
        writer.uint32(264).bool(message.wellKnown.value);
        break;
      case "ipWithPrefixlen":
        writer.uint32(208).bool(message.wellKnown.value);
        break;
      case "ipv4WithPrefixlen":
        writer.uint32(216).bool(message.wellKnown.value);
        break;
      case "ipv6WithPrefixlen":
        writer.uint32(224).bool(message.wellKnown.value);
        break;
      case "ipPrefix":
        writer.uint32(232).bool(message.wellKnown.value);
        break;
      case "ipv4Prefix":
        writer.uint32(240).bool(message.wellKnown.value);
        break;
      case "ipv6Prefix":
        writer.uint32(248).bool(message.wellKnown.value);
        break;
      case "hostAndPort":
        writer.uint32(256).bool(message.wellKnown.value);
        break;
      case "wellKnownRegex":
        writer.uint32(192).int32(message.wellKnown.value);
        break;
    }
    if (message.strict !== undefined && message.strict !== false) {
      writer.uint32(200).bool(message.strict);
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(274).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.const = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.len = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minLen = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxLen = reader.uint64().toString();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.lenBytes = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minBytes = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxBytes = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.suffix = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.contains = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.notContains = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.in!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.notIn!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.wellKnown = { $case: "email", value: reader.bool() };
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.wellKnown = { $case: "hostname", value: reader.bool() };
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.wellKnown = { $case: "ip", value: reader.bool() };
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.wellKnown = { $case: "ipv4", value: reader.bool() };
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.wellKnown = { $case: "ipv6", value: reader.bool() };
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.wellKnown = { $case: "uri", value: reader.bool() };
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.wellKnown = { $case: "uriRef", value: reader.bool() };
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.wellKnown = { $case: "address", value: reader.bool() };
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.wellKnown = { $case: "uuid", value: reader.bool() };
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.wellKnown = { $case: "tuuid", value: reader.bool() };
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.wellKnown = { $case: "ipWithPrefixlen", value: reader.bool() };
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.wellKnown = { $case: "ipv4WithPrefixlen", value: reader.bool() };
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.wellKnown = { $case: "ipv6WithPrefixlen", value: reader.bool() };
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.wellKnown = { $case: "ipPrefix", value: reader.bool() };
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.wellKnown = { $case: "ipv4Prefix", value: reader.bool() };
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.wellKnown = { $case: "ipv6Prefix", value: reader.bool() };
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.wellKnown = { $case: "hostAndPort", value: reader.bool() };
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.wellKnown = { $case: "wellKnownRegex", value: reader.int32() as any };
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.strict = reader.bool();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.example!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringRules {
    return {
      const: isSet(object.const) ? globalThis.String(object.const) : "",
      len: isSet(object.len) ? globalThis.String(object.len) : "0",
      minLen: isSet(object.minLen) ? globalThis.String(object.minLen) : "0",
      maxLen: isSet(object.maxLen) ? globalThis.String(object.maxLen) : "0",
      lenBytes: isSet(object.lenBytes) ? globalThis.String(object.lenBytes) : "0",
      minBytes: isSet(object.minBytes) ? globalThis.String(object.minBytes) : "0",
      maxBytes: isSet(object.maxBytes) ? globalThis.String(object.maxBytes) : "0",
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      suffix: isSet(object.suffix) ? globalThis.String(object.suffix) : "",
      contains: isSet(object.contains) ? globalThis.String(object.contains) : "",
      notContains: isSet(object.notContains) ? globalThis.String(object.notContains) : "",
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.String(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.String(e)) : [],
      wellKnown: isSet(object.email)
        ? { $case: "email", value: globalThis.Boolean(object.email) }
        : isSet(object.hostname)
        ? { $case: "hostname", value: globalThis.Boolean(object.hostname) }
        : isSet(object.ip)
        ? { $case: "ip", value: globalThis.Boolean(object.ip) }
        : isSet(object.ipv4)
        ? { $case: "ipv4", value: globalThis.Boolean(object.ipv4) }
        : isSet(object.ipv6)
        ? { $case: "ipv6", value: globalThis.Boolean(object.ipv6) }
        : isSet(object.uri)
        ? { $case: "uri", value: globalThis.Boolean(object.uri) }
        : isSet(object.uriRef)
        ? { $case: "uriRef", value: globalThis.Boolean(object.uriRef) }
        : isSet(object.address)
        ? { $case: "address", value: globalThis.Boolean(object.address) }
        : isSet(object.uuid)
        ? { $case: "uuid", value: globalThis.Boolean(object.uuid) }
        : isSet(object.tuuid)
        ? { $case: "tuuid", value: globalThis.Boolean(object.tuuid) }
        : isSet(object.ipWithPrefixlen)
        ? { $case: "ipWithPrefixlen", value: globalThis.Boolean(object.ipWithPrefixlen) }
        : isSet(object.ipv4WithPrefixlen)
        ? { $case: "ipv4WithPrefixlen", value: globalThis.Boolean(object.ipv4WithPrefixlen) }
        : isSet(object.ipv6WithPrefixlen)
        ? { $case: "ipv6WithPrefixlen", value: globalThis.Boolean(object.ipv6WithPrefixlen) }
        : isSet(object.ipPrefix)
        ? { $case: "ipPrefix", value: globalThis.Boolean(object.ipPrefix) }
        : isSet(object.ipv4Prefix)
        ? { $case: "ipv4Prefix", value: globalThis.Boolean(object.ipv4Prefix) }
        : isSet(object.ipv6Prefix)
        ? { $case: "ipv6Prefix", value: globalThis.Boolean(object.ipv6Prefix) }
        : isSet(object.hostAndPort)
        ? { $case: "hostAndPort", value: globalThis.Boolean(object.hostAndPort) }
        : isSet(object.wellKnownRegex)
        ? { $case: "wellKnownRegex", value: knownRegexFromJSON(object.wellKnownRegex) }
        : undefined,
      strict: isSet(object.strict) ? globalThis.Boolean(object.strict) : false,
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: StringRules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== "") {
      obj.const = message.const;
    }
    if (message.len !== undefined && message.len !== "0") {
      obj.len = message.len;
    }
    if (message.minLen !== undefined && message.minLen !== "0") {
      obj.minLen = message.minLen;
    }
    if (message.maxLen !== undefined && message.maxLen !== "0") {
      obj.maxLen = message.maxLen;
    }
    if (message.lenBytes !== undefined && message.lenBytes !== "0") {
      obj.lenBytes = message.lenBytes;
    }
    if (message.minBytes !== undefined && message.minBytes !== "0") {
      obj.minBytes = message.minBytes;
    }
    if (message.maxBytes !== undefined && message.maxBytes !== "0") {
      obj.maxBytes = message.maxBytes;
    }
    if (message.pattern !== undefined && message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.prefix !== undefined && message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.suffix !== undefined && message.suffix !== "") {
      obj.suffix = message.suffix;
    }
    if (message.contains !== undefined && message.contains !== "") {
      obj.contains = message.contains;
    }
    if (message.notContains !== undefined && message.notContains !== "") {
      obj.notContains = message.notContains;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn;
    }
    if (message.wellKnown?.$case === "email") {
      obj.email = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "hostname") {
      obj.hostname = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ip") {
      obj.ip = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ipv4") {
      obj.ipv4 = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ipv6") {
      obj.ipv6 = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "uri") {
      obj.uri = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "uriRef") {
      obj.uriRef = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "address") {
      obj.address = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "uuid") {
      obj.uuid = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "tuuid") {
      obj.tuuid = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ipWithPrefixlen") {
      obj.ipWithPrefixlen = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ipv4WithPrefixlen") {
      obj.ipv4WithPrefixlen = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ipv6WithPrefixlen") {
      obj.ipv6WithPrefixlen = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ipPrefix") {
      obj.ipPrefix = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ipv4Prefix") {
      obj.ipv4Prefix = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ipv6Prefix") {
      obj.ipv6Prefix = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "hostAndPort") {
      obj.hostAndPort = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "wellKnownRegex") {
      obj.wellKnownRegex = knownRegexToJSON(message.wellKnown.value);
    }
    if (message.strict !== undefined && message.strict !== false) {
      obj.strict = message.strict;
    }
    if (message.example?.length) {
      obj.example = message.example;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StringRules>, I>>(base?: I): StringRules {
    return StringRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StringRules>, I>>(object: I): StringRules {
    const message = createBaseStringRules();
    message.const = object.const ?? "";
    message.len = object.len ?? "0";
    message.minLen = object.minLen ?? "0";
    message.maxLen = object.maxLen ?? "0";
    message.lenBytes = object.lenBytes ?? "0";
    message.minBytes = object.minBytes ?? "0";
    message.maxBytes = object.maxBytes ?? "0";
    message.pattern = object.pattern ?? "";
    message.prefix = object.prefix ?? "";
    message.suffix = object.suffix ?? "";
    message.contains = object.contains ?? "";
    message.notContains = object.notContains ?? "";
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    switch (object.wellKnown?.$case) {
      case "email": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "email", value: object.wellKnown.value };
        }
        break;
      }
      case "hostname": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "hostname", value: object.wellKnown.value };
        }
        break;
      }
      case "ip": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ip", value: object.wellKnown.value };
        }
        break;
      }
      case "ipv4": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ipv4", value: object.wellKnown.value };
        }
        break;
      }
      case "ipv6": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ipv6", value: object.wellKnown.value };
        }
        break;
      }
      case "uri": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "uri", value: object.wellKnown.value };
        }
        break;
      }
      case "uriRef": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "uriRef", value: object.wellKnown.value };
        }
        break;
      }
      case "address": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "address", value: object.wellKnown.value };
        }
        break;
      }
      case "uuid": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "uuid", value: object.wellKnown.value };
        }
        break;
      }
      case "tuuid": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "tuuid", value: object.wellKnown.value };
        }
        break;
      }
      case "ipWithPrefixlen": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ipWithPrefixlen", value: object.wellKnown.value };
        }
        break;
      }
      case "ipv4WithPrefixlen": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ipv4WithPrefixlen", value: object.wellKnown.value };
        }
        break;
      }
      case "ipv6WithPrefixlen": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ipv6WithPrefixlen", value: object.wellKnown.value };
        }
        break;
      }
      case "ipPrefix": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ipPrefix", value: object.wellKnown.value };
        }
        break;
      }
      case "ipv4Prefix": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ipv4Prefix", value: object.wellKnown.value };
        }
        break;
      }
      case "ipv6Prefix": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ipv6Prefix", value: object.wellKnown.value };
        }
        break;
      }
      case "hostAndPort": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "hostAndPort", value: object.wellKnown.value };
        }
        break;
      }
      case "wellKnownRegex": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "wellKnownRegex", value: object.wellKnown.value };
        }
        break;
      }
    }
    message.strict = object.strict ?? false;
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseBytesRules(): BytesRules {
  return {
    const: Buffer.alloc(0),
    len: "0",
    minLen: "0",
    maxLen: "0",
    pattern: "",
    prefix: Buffer.alloc(0),
    suffix: Buffer.alloc(0),
    contains: Buffer.alloc(0),
    in: [],
    notIn: [],
    wellKnown: undefined,
    example: [],
  };
}

export const BytesRules: MessageFns<BytesRules> = {
  encode(message: BytesRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const.length !== 0) {
      writer.uint32(10).bytes(message.const);
    }
    if (message.len !== undefined && message.len !== "0") {
      writer.uint32(104).uint64(message.len);
    }
    if (message.minLen !== undefined && message.minLen !== "0") {
      writer.uint32(16).uint64(message.minLen);
    }
    if (message.maxLen !== undefined && message.maxLen !== "0") {
      writer.uint32(24).uint64(message.maxLen);
    }
    if (message.pattern !== undefined && message.pattern !== "") {
      writer.uint32(34).string(message.pattern);
    }
    if (message.prefix !== undefined && message.prefix.length !== 0) {
      writer.uint32(42).bytes(message.prefix);
    }
    if (message.suffix !== undefined && message.suffix.length !== 0) {
      writer.uint32(50).bytes(message.suffix);
    }
    if (message.contains !== undefined && message.contains.length !== 0) {
      writer.uint32(58).bytes(message.contains);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(66).bytes(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(74).bytes(v!);
      }
    }
    switch (message.wellKnown?.$case) {
      case "ip":
        writer.uint32(80).bool(message.wellKnown.value);
        break;
      case "ipv4":
        writer.uint32(88).bool(message.wellKnown.value);
        break;
      case "ipv6":
        writer.uint32(96).bool(message.wellKnown.value);
        break;
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(114).bytes(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BytesRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBytesRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.const = Buffer.from(reader.bytes());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.len = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minLen = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxLen = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.prefix = Buffer.from(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.suffix = Buffer.from(reader.bytes());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contains = Buffer.from(reader.bytes());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const el = Buffer.from(reader.bytes());
          if (el !== undefined) {
            message.in!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const el = Buffer.from(reader.bytes());
          if (el !== undefined) {
            message.notIn!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.wellKnown = { $case: "ip", value: reader.bool() };
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.wellKnown = { $case: "ipv4", value: reader.bool() };
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.wellKnown = { $case: "ipv6", value: reader.bool() };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const el = Buffer.from(reader.bytes());
          if (el !== undefined) {
            message.example!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BytesRules {
    return {
      const: isSet(object.const) ? Buffer.from(bytesFromBase64(object.const)) : Buffer.alloc(0),
      len: isSet(object.len) ? globalThis.String(object.len) : "0",
      minLen: isSet(object.minLen) ? globalThis.String(object.minLen) : "0",
      maxLen: isSet(object.maxLen) ? globalThis.String(object.maxLen) : "0",
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
      prefix: isSet(object.prefix) ? Buffer.from(bytesFromBase64(object.prefix)) : Buffer.alloc(0),
      suffix: isSet(object.suffix) ? Buffer.from(bytesFromBase64(object.suffix)) : Buffer.alloc(0),
      contains: isSet(object.contains) ? Buffer.from(bytesFromBase64(object.contains)) : Buffer.alloc(0),
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => Buffer.from(bytesFromBase64(e))) : [],
      notIn: globalThis.Array.isArray(object?.notIn)
        ? object.notIn.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      wellKnown: isSet(object.ip)
        ? { $case: "ip", value: globalThis.Boolean(object.ip) }
        : isSet(object.ipv4)
        ? { $case: "ipv4", value: globalThis.Boolean(object.ipv4) }
        : isSet(object.ipv6)
        ? { $case: "ipv6", value: globalThis.Boolean(object.ipv6) }
        : undefined,
      example: globalThis.Array.isArray(object?.example)
        ? object.example.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
    };
  },

  toJSON(message: BytesRules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const.length !== 0) {
      obj.const = base64FromBytes(message.const);
    }
    if (message.len !== undefined && message.len !== "0") {
      obj.len = message.len;
    }
    if (message.minLen !== undefined && message.minLen !== "0") {
      obj.minLen = message.minLen;
    }
    if (message.maxLen !== undefined && message.maxLen !== "0") {
      obj.maxLen = message.maxLen;
    }
    if (message.pattern !== undefined && message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.prefix !== undefined && message.prefix.length !== 0) {
      obj.prefix = base64FromBytes(message.prefix);
    }
    if (message.suffix !== undefined && message.suffix.length !== 0) {
      obj.suffix = base64FromBytes(message.suffix);
    }
    if (message.contains !== undefined && message.contains.length !== 0) {
      obj.contains = base64FromBytes(message.contains);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => base64FromBytes(e));
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn.map((e) => base64FromBytes(e));
    }
    if (message.wellKnown?.$case === "ip") {
      obj.ip = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ipv4") {
      obj.ipv4 = message.wellKnown.value;
    } else if (message.wellKnown?.$case === "ipv6") {
      obj.ipv6 = message.wellKnown.value;
    }
    if (message.example?.length) {
      obj.example = message.example.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BytesRules>, I>>(base?: I): BytesRules {
    return BytesRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BytesRules>, I>>(object: I): BytesRules {
    const message = createBaseBytesRules();
    message.const = object.const ?? Buffer.alloc(0);
    message.len = object.len ?? "0";
    message.minLen = object.minLen ?? "0";
    message.maxLen = object.maxLen ?? "0";
    message.pattern = object.pattern ?? "";
    message.prefix = object.prefix ?? Buffer.alloc(0);
    message.suffix = object.suffix ?? Buffer.alloc(0);
    message.contains = object.contains ?? Buffer.alloc(0);
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    switch (object.wellKnown?.$case) {
      case "ip": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ip", value: object.wellKnown.value };
        }
        break;
      }
      case "ipv4": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ipv4", value: object.wellKnown.value };
        }
        break;
      }
      case "ipv6": {
        if (object.wellKnown?.value !== undefined && object.wellKnown?.value !== null) {
          message.wellKnown = { $case: "ipv6", value: object.wellKnown.value };
        }
        break;
      }
    }
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseEnumRules(): EnumRules {
  return { const: 0, definedOnly: false, in: [], notIn: [], example: [] };
}

export const EnumRules: MessageFns<EnumRules> = {
  encode(message: EnumRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).int32(message.const);
    }
    if (message.definedOnly !== undefined && message.definedOnly !== false) {
      writer.uint32(16).bool(message.definedOnly);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(24).int32(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(32).int32(v!);
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        writer.uint32(40).int32(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.definedOnly = reader.bool();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.in!.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 32) {
            message.notIn!.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.notIn!.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag === 40) {
            message.example!.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.example!.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumRules {
    return {
      const: isSet(object.const) ? globalThis.Number(object.const) : 0,
      definedOnly: isSet(object.definedOnly) ? globalThis.Boolean(object.definedOnly) : false,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.Number(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: EnumRules): unknown {
    const obj: any = {};
    if (message.const !== undefined && message.const !== 0) {
      obj.const = Math.round(message.const);
    }
    if (message.definedOnly !== undefined && message.definedOnly !== false) {
      obj.definedOnly = message.definedOnly;
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn.map((e) => Math.round(e));
    }
    if (message.example?.length) {
      obj.example = message.example.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnumRules>, I>>(base?: I): EnumRules {
    return EnumRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnumRules>, I>>(object: I): EnumRules {
    const message = createBaseEnumRules();
    message.const = object.const ?? 0;
    message.definedOnly = object.definedOnly ?? false;
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseRepeatedRules(): RepeatedRules {
  return { minItems: "0", maxItems: "0", unique: false, items: undefined };
}

export const RepeatedRules: MessageFns<RepeatedRules> = {
  encode(message: RepeatedRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minItems !== undefined && message.minItems !== "0") {
      writer.uint32(8).uint64(message.minItems);
    }
    if (message.maxItems !== undefined && message.maxItems !== "0") {
      writer.uint32(16).uint64(message.maxItems);
    }
    if (message.unique !== undefined && message.unique !== false) {
      writer.uint32(24).bool(message.unique);
    }
    if (message.items !== undefined) {
      FieldConstraints.encode(message.items, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepeatedRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepeatedRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minItems = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxItems = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.unique = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.items = FieldConstraints.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepeatedRules {
    return {
      minItems: isSet(object.minItems) ? globalThis.String(object.minItems) : "0",
      maxItems: isSet(object.maxItems) ? globalThis.String(object.maxItems) : "0",
      unique: isSet(object.unique) ? globalThis.Boolean(object.unique) : false,
      items: isSet(object.items) ? FieldConstraints.fromJSON(object.items) : undefined,
    };
  },

  toJSON(message: RepeatedRules): unknown {
    const obj: any = {};
    if (message.minItems !== undefined && message.minItems !== "0") {
      obj.minItems = message.minItems;
    }
    if (message.maxItems !== undefined && message.maxItems !== "0") {
      obj.maxItems = message.maxItems;
    }
    if (message.unique !== undefined && message.unique !== false) {
      obj.unique = message.unique;
    }
    if (message.items !== undefined) {
      obj.items = FieldConstraints.toJSON(message.items);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RepeatedRules>, I>>(base?: I): RepeatedRules {
    return RepeatedRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RepeatedRules>, I>>(object: I): RepeatedRules {
    const message = createBaseRepeatedRules();
    message.minItems = object.minItems ?? "0";
    message.maxItems = object.maxItems ?? "0";
    message.unique = object.unique ?? false;
    message.items = (object.items !== undefined && object.items !== null)
      ? FieldConstraints.fromPartial(object.items)
      : undefined;
    return message;
  },
};

function createBaseMapRules(): MapRules {
  return { minPairs: "0", maxPairs: "0", keys: undefined, values: undefined };
}

export const MapRules: MessageFns<MapRules> = {
  encode(message: MapRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minPairs !== undefined && message.minPairs !== "0") {
      writer.uint32(8).uint64(message.minPairs);
    }
    if (message.maxPairs !== undefined && message.maxPairs !== "0") {
      writer.uint32(16).uint64(message.maxPairs);
    }
    if (message.keys !== undefined) {
      FieldConstraints.encode(message.keys, writer.uint32(34).fork()).join();
    }
    if (message.values !== undefined) {
      FieldConstraints.encode(message.values, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minPairs = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxPairs = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keys = FieldConstraints.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.values = FieldConstraints.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapRules {
    return {
      minPairs: isSet(object.minPairs) ? globalThis.String(object.minPairs) : "0",
      maxPairs: isSet(object.maxPairs) ? globalThis.String(object.maxPairs) : "0",
      keys: isSet(object.keys) ? FieldConstraints.fromJSON(object.keys) : undefined,
      values: isSet(object.values) ? FieldConstraints.fromJSON(object.values) : undefined,
    };
  },

  toJSON(message: MapRules): unknown {
    const obj: any = {};
    if (message.minPairs !== undefined && message.minPairs !== "0") {
      obj.minPairs = message.minPairs;
    }
    if (message.maxPairs !== undefined && message.maxPairs !== "0") {
      obj.maxPairs = message.maxPairs;
    }
    if (message.keys !== undefined) {
      obj.keys = FieldConstraints.toJSON(message.keys);
    }
    if (message.values !== undefined) {
      obj.values = FieldConstraints.toJSON(message.values);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapRules>, I>>(base?: I): MapRules {
    return MapRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapRules>, I>>(object: I): MapRules {
    const message = createBaseMapRules();
    message.minPairs = object.minPairs ?? "0";
    message.maxPairs = object.maxPairs ?? "0";
    message.keys = (object.keys !== undefined && object.keys !== null)
      ? FieldConstraints.fromPartial(object.keys)
      : undefined;
    message.values = (object.values !== undefined && object.values !== null)
      ? FieldConstraints.fromPartial(object.values)
      : undefined;
    return message;
  },
};

function createBaseAnyRules(): AnyRules {
  return { in: [], notIn: [] };
}

export const AnyRules: MessageFns<AnyRules> = {
  encode(message: AnyRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        writer.uint32(26).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnyRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnyRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.in!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.notIn!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnyRules {
    return {
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.String(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AnyRules): unknown {
    const obj: any = {};
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnyRules>, I>>(base?: I): AnyRules {
    return AnyRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnyRules>, I>>(object: I): AnyRules {
    const message = createBaseAnyRules();
    message.in = object.in?.map((e) => e) || [];
    message.notIn = object.notIn?.map((e) => e) || [];
    return message;
  },
};

function createBaseDurationRules(): DurationRules {
  return { const: undefined, lessThan: undefined, greaterThan: undefined, in: [], notIn: [], example: [] };
}

export const DurationRules: MessageFns<DurationRules> = {
  encode(message: DurationRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined) {
      Duration.encode(message.const, writer.uint32(18).fork()).join();
    }
    switch (message.lessThan?.$case) {
      case "lt":
        Duration.encode(message.lessThan.value, writer.uint32(26).fork()).join();
        break;
      case "lte":
        Duration.encode(message.lessThan.value, writer.uint32(34).fork()).join();
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        Duration.encode(message.greaterThan.value, writer.uint32(42).fork()).join();
        break;
      case "gte":
        Duration.encode(message.greaterThan.value, writer.uint32(50).fork()).join();
        break;
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        Duration.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    if (message.notIn !== undefined && message.notIn.length !== 0) {
      for (const v of message.notIn) {
        Duration.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        Duration.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.const = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lessThan = { $case: "lt", value: Duration.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lessThan = { $case: "lte", value: Duration.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.greaterThan = { $case: "gt", value: Duration.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.greaterThan = { $case: "gte", value: Duration.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const el = Duration.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.in!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const el = Duration.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.notIn!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const el = Duration.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.example!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationRules {
    return {
      const: isSet(object.const) ? Duration.fromJSON(object.const) : undefined,
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: Duration.fromJSON(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: Duration.fromJSON(object.lte) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: Duration.fromJSON(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: Duration.fromJSON(object.gte) }
        : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => Duration.fromJSON(e)) : [],
      notIn: globalThis.Array.isArray(object?.notIn) ? object.notIn.map((e: any) => Duration.fromJSON(e)) : [],
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => Duration.fromJSON(e)) : [],
    };
  },

  toJSON(message: DurationRules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Duration.toJSON(message.const);
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = Duration.toJSON(message.lessThan.value);
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = Duration.toJSON(message.lessThan.value);
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = Duration.toJSON(message.greaterThan.value);
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = Duration.toJSON(message.greaterThan.value);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Duration.toJSON(e));
    }
    if (message.notIn?.length) {
      obj.notIn = message.notIn.map((e) => Duration.toJSON(e));
    }
    if (message.example?.length) {
      obj.example = message.example.map((e) => Duration.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DurationRules>, I>>(base?: I): DurationRules {
    return DurationRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DurationRules>, I>>(object: I): DurationRules {
    const message = createBaseDurationRules();
    message.const = (object.const !== undefined && object.const !== null)
      ? Duration.fromPartial(object.const)
      : undefined;
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: Duration.fromPartial(object.lessThan.value) };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: Duration.fromPartial(object.lessThan.value) };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: Duration.fromPartial(object.greaterThan.value) };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: Duration.fromPartial(object.greaterThan.value) };
        }
        break;
      }
    }
    message.in = object.in?.map((e) => Duration.fromPartial(e)) || [];
    message.notIn = object.notIn?.map((e) => Duration.fromPartial(e)) || [];
    message.example = object.example?.map((e) => Duration.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTimestampRules(): TimestampRules {
  return { const: undefined, lessThan: undefined, greaterThan: undefined, within: undefined, example: [] };
}

export const TimestampRules: MessageFns<TimestampRules> = {
  encode(message: TimestampRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined) {
      Timestamp.encode(toTimestamp(message.const), writer.uint32(18).fork()).join();
    }
    switch (message.lessThan?.$case) {
      case "lt":
        Timestamp.encode(toTimestamp(message.lessThan.value), writer.uint32(26).fork()).join();
        break;
      case "lte":
        Timestamp.encode(toTimestamp(message.lessThan.value), writer.uint32(34).fork()).join();
        break;
      case "ltNow":
        writer.uint32(56).bool(message.lessThan.value);
        break;
    }
    switch (message.greaterThan?.$case) {
      case "gt":
        Timestamp.encode(toTimestamp(message.greaterThan.value), writer.uint32(42).fork()).join();
        break;
      case "gte":
        Timestamp.encode(toTimestamp(message.greaterThan.value), writer.uint32(50).fork()).join();
        break;
      case "gtNow":
        writer.uint32(64).bool(message.greaterThan.value);
        break;
    }
    if (message.within !== undefined) {
      Duration.encode(message.within, writer.uint32(74).fork()).join();
    }
    if (message.example !== undefined && message.example.length !== 0) {
      for (const v of message.example) {
        Timestamp.encode(toTimestamp(v!), writer.uint32(82).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.const = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lessThan = { $case: "lt", value: fromTimestamp(Timestamp.decode(reader, reader.uint32())) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lessThan = { $case: "lte", value: fromTimestamp(Timestamp.decode(reader, reader.uint32())) };
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lessThan = { $case: "ltNow", value: reader.bool() };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.greaterThan = { $case: "gt", value: fromTimestamp(Timestamp.decode(reader, reader.uint32())) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.greaterThan = { $case: "gte", value: fromTimestamp(Timestamp.decode(reader, reader.uint32())) };
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.greaterThan = { $case: "gtNow", value: reader.bool() };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.within = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const el = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          if (el !== undefined) {
            message.example!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimestampRules {
    return {
      const: isSet(object.const) ? fromJsonTimestamp(object.const) : undefined,
      lessThan: isSet(object.lt)
        ? { $case: "lt", value: fromJsonTimestamp(object.lt) }
        : isSet(object.lte)
        ? { $case: "lte", value: fromJsonTimestamp(object.lte) }
        : isSet(object.ltNow)
        ? { $case: "ltNow", value: globalThis.Boolean(object.ltNow) }
        : undefined,
      greaterThan: isSet(object.gt)
        ? { $case: "gt", value: fromJsonTimestamp(object.gt) }
        : isSet(object.gte)
        ? { $case: "gte", value: fromJsonTimestamp(object.gte) }
        : isSet(object.gtNow)
        ? { $case: "gtNow", value: globalThis.Boolean(object.gtNow) }
        : undefined,
      within: isSet(object.within) ? Duration.fromJSON(object.within) : undefined,
      example: globalThis.Array.isArray(object?.example) ? object.example.map((e: any) => fromJsonTimestamp(e)) : [],
    };
  },

  toJSON(message: TimestampRules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = message.const.toISOString();
    }
    if (message.lessThan?.$case === "lt") {
      obj.lt = message.lessThan.value.toISOString();
    } else if (message.lessThan?.$case === "lte") {
      obj.lte = message.lessThan.value.toISOString();
    } else if (message.lessThan?.$case === "ltNow") {
      obj.ltNow = message.lessThan.value;
    }
    if (message.greaterThan?.$case === "gt") {
      obj.gt = message.greaterThan.value.toISOString();
    } else if (message.greaterThan?.$case === "gte") {
      obj.gte = message.greaterThan.value.toISOString();
    } else if (message.greaterThan?.$case === "gtNow") {
      obj.gtNow = message.greaterThan.value;
    }
    if (message.within !== undefined) {
      obj.within = Duration.toJSON(message.within);
    }
    if (message.example?.length) {
      obj.example = message.example.map((e) => e.toISOString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimestampRules>, I>>(base?: I): TimestampRules {
    return TimestampRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimestampRules>, I>>(object: I): TimestampRules {
    const message = createBaseTimestampRules();
    message.const = object.const ?? undefined;
    switch (object.lessThan?.$case) {
      case "lt": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lt", value: object.lessThan.value };
        }
        break;
      }
      case "lte": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "lte", value: object.lessThan.value };
        }
        break;
      }
      case "ltNow": {
        if (object.lessThan?.value !== undefined && object.lessThan?.value !== null) {
          message.lessThan = { $case: "ltNow", value: object.lessThan.value };
        }
        break;
      }
    }
    switch (object.greaterThan?.$case) {
      case "gt": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gt", value: object.greaterThan.value };
        }
        break;
      }
      case "gte": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gte", value: object.greaterThan.value };
        }
        break;
      }
      case "gtNow": {
        if (object.greaterThan?.value !== undefined && object.greaterThan?.value !== null) {
          message.greaterThan = { $case: "gtNow", value: object.greaterThan.value };
        }
        break;
      }
    }
    message.within = (object.within !== undefined && object.within !== null)
      ? Duration.fromPartial(object.within)
      : undefined;
    message.example = object.example?.map((e) => e) || [];
    return message;
  },
};

function createBaseViolations(): Violations {
  return { violations: [] };
}

export const Violations: MessageFns<Violations> = {
  encode(message: Violations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.violations !== undefined && message.violations.length !== 0) {
      for (const v of message.violations) {
        Violation.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Violations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViolations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = Violation.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.violations!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Violations {
    return {
      violations: globalThis.Array.isArray(object?.violations)
        ? object.violations.map((e: any) => Violation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Violations): unknown {
    const obj: any = {};
    if (message.violations?.length) {
      obj.violations = message.violations.map((e) => Violation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Violations>, I>>(base?: I): Violations {
    return Violations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Violations>, I>>(object: I): Violations {
    const message = createBaseViolations();
    message.violations = object.violations?.map((e) => Violation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseViolation(): Violation {
  return { field: undefined, rule: undefined, constraintId: "", message: "", forKey: false };
}

export const Violation: MessageFns<Violation> = {
  encode(message: Violation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined) {
      FieldPath.encode(message.field, writer.uint32(42).fork()).join();
    }
    if (message.rule !== undefined) {
      FieldPath.encode(message.rule, writer.uint32(50).fork()).join();
    }
    if (message.constraintId !== undefined && message.constraintId !== "") {
      writer.uint32(18).string(message.constraintId);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.forKey !== undefined && message.forKey !== false) {
      writer.uint32(32).bool(message.forKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Violation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViolation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.field = FieldPath.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rule = FieldPath.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.constraintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.forKey = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Violation {
    return {
      field: isSet(object.field) ? FieldPath.fromJSON(object.field) : undefined,
      rule: isSet(object.rule) ? FieldPath.fromJSON(object.rule) : undefined,
      constraintId: isSet(object.constraintId) ? globalThis.String(object.constraintId) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      forKey: isSet(object.forKey) ? globalThis.Boolean(object.forKey) : false,
    };
  },

  toJSON(message: Violation): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = FieldPath.toJSON(message.field);
    }
    if (message.rule !== undefined) {
      obj.rule = FieldPath.toJSON(message.rule);
    }
    if (message.constraintId !== undefined && message.constraintId !== "") {
      obj.constraintId = message.constraintId;
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.forKey !== undefined && message.forKey !== false) {
      obj.forKey = message.forKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Violation>, I>>(base?: I): Violation {
    return Violation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Violation>, I>>(object: I): Violation {
    const message = createBaseViolation();
    message.field = (object.field !== undefined && object.field !== null)
      ? FieldPath.fromPartial(object.field)
      : undefined;
    message.rule = (object.rule !== undefined && object.rule !== null) ? FieldPath.fromPartial(object.rule) : undefined;
    message.constraintId = object.constraintId ?? "";
    message.message = object.message ?? "";
    message.forKey = object.forKey ?? false;
    return message;
  },
};

function createBaseFieldPath(): FieldPath {
  return { elements: [] };
}

export const FieldPath: MessageFns<FieldPath> = {
  encode(message: FieldPath, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.elements !== undefined && message.elements.length !== 0) {
      for (const v of message.elements) {
        FieldPathElement.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldPath {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldPath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = FieldPathElement.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.elements!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldPath {
    return {
      elements: globalThis.Array.isArray(object?.elements)
        ? object.elements.map((e: any) => FieldPathElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FieldPath): unknown {
    const obj: any = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => FieldPathElement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldPath>, I>>(base?: I): FieldPath {
    return FieldPath.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldPath>, I>>(object: I): FieldPath {
    const message = createBaseFieldPath();
    message.elements = object.elements?.map((e) => FieldPathElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFieldPathElement(): FieldPathElement {
  return { fieldNumber: 0, fieldName: "", fieldType: 1, keyType: 1, valueType: 1, subscript: undefined };
}

export const FieldPathElement: MessageFns<FieldPathElement> = {
  encode(message: FieldPathElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldNumber !== undefined && message.fieldNumber !== 0) {
      writer.uint32(8).int32(message.fieldNumber);
    }
    if (message.fieldName !== undefined && message.fieldName !== "") {
      writer.uint32(18).string(message.fieldName);
    }
    if (message.fieldType !== undefined && message.fieldType !== 1) {
      writer.uint32(24).int32(message.fieldType);
    }
    if (message.keyType !== undefined && message.keyType !== 1) {
      writer.uint32(32).int32(message.keyType);
    }
    if (message.valueType !== undefined && message.valueType !== 1) {
      writer.uint32(40).int32(message.valueType);
    }
    switch (message.subscript?.$case) {
      case "index":
        writer.uint32(48).uint64(message.subscript.value);
        break;
      case "boolKey":
        writer.uint32(56).bool(message.subscript.value);
        break;
      case "intKey":
        writer.uint32(64).int64(message.subscript.value);
        break;
      case "uintKey":
        writer.uint32(72).uint64(message.subscript.value);
        break;
      case "stringKey":
        writer.uint32(82).string(message.subscript.value);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldPathElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldPathElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fieldNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fieldType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.keyType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.valueType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.subscript = { $case: "index", value: reader.uint64().toString() };
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.subscript = { $case: "boolKey", value: reader.bool() };
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.subscript = { $case: "intKey", value: reader.int64().toString() };
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.subscript = { $case: "uintKey", value: reader.uint64().toString() };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.subscript = { $case: "stringKey", value: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldPathElement {
    return {
      fieldNumber: isSet(object.fieldNumber) ? globalThis.Number(object.fieldNumber) : 0,
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      fieldType: isSet(object.fieldType) ? fieldDescriptorProto_TypeFromJSON(object.fieldType) : 1,
      keyType: isSet(object.keyType) ? fieldDescriptorProto_TypeFromJSON(object.keyType) : 1,
      valueType: isSet(object.valueType) ? fieldDescriptorProto_TypeFromJSON(object.valueType) : 1,
      subscript: isSet(object.index)
        ? { $case: "index", value: globalThis.String(object.index) }
        : isSet(object.boolKey)
        ? { $case: "boolKey", value: globalThis.Boolean(object.boolKey) }
        : isSet(object.intKey)
        ? { $case: "intKey", value: globalThis.String(object.intKey) }
        : isSet(object.uintKey)
        ? { $case: "uintKey", value: globalThis.String(object.uintKey) }
        : isSet(object.stringKey)
        ? { $case: "stringKey", value: globalThis.String(object.stringKey) }
        : undefined,
    };
  },

  toJSON(message: FieldPathElement): unknown {
    const obj: any = {};
    if (message.fieldNumber !== undefined && message.fieldNumber !== 0) {
      obj.fieldNumber = Math.round(message.fieldNumber);
    }
    if (message.fieldName !== undefined && message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.fieldType !== undefined && message.fieldType !== 1) {
      obj.fieldType = fieldDescriptorProto_TypeToJSON(message.fieldType);
    }
    if (message.keyType !== undefined && message.keyType !== 1) {
      obj.keyType = fieldDescriptorProto_TypeToJSON(message.keyType);
    }
    if (message.valueType !== undefined && message.valueType !== 1) {
      obj.valueType = fieldDescriptorProto_TypeToJSON(message.valueType);
    }
    if (message.subscript?.$case === "index") {
      obj.index = message.subscript.value;
    } else if (message.subscript?.$case === "boolKey") {
      obj.boolKey = message.subscript.value;
    } else if (message.subscript?.$case === "intKey") {
      obj.intKey = message.subscript.value;
    } else if (message.subscript?.$case === "uintKey") {
      obj.uintKey = message.subscript.value;
    } else if (message.subscript?.$case === "stringKey") {
      obj.stringKey = message.subscript.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldPathElement>, I>>(base?: I): FieldPathElement {
    return FieldPathElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldPathElement>, I>>(object: I): FieldPathElement {
    const message = createBaseFieldPathElement();
    message.fieldNumber = object.fieldNumber ?? 0;
    message.fieldName = object.fieldName ?? "";
    message.fieldType = object.fieldType ?? 1;
    message.keyType = object.keyType ?? 1;
    message.valueType = object.valueType ?? 1;
    switch (object.subscript?.$case) {
      case "index": {
        if (object.subscript?.value !== undefined && object.subscript?.value !== null) {
          message.subscript = { $case: "index", value: object.subscript.value };
        }
        break;
      }
      case "boolKey": {
        if (object.subscript?.value !== undefined && object.subscript?.value !== null) {
          message.subscript = { $case: "boolKey", value: object.subscript.value };
        }
        break;
      }
      case "intKey": {
        if (object.subscript?.value !== undefined && object.subscript?.value !== null) {
          message.subscript = { $case: "intKey", value: object.subscript.value };
        }
        break;
      }
      case "uintKey": {
        if (object.subscript?.value !== undefined && object.subscript?.value !== null) {
          message.subscript = { $case: "uintKey", value: object.subscript.value };
        }
        break;
      }
      case "stringKey": {
        if (object.subscript?.value !== undefined && object.subscript?.value !== null) {
          message.subscript = { $case: "stringKey", value: object.subscript.value };
        }
        break;
      }
    }
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

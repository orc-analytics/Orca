// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package postgresql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAlgorithm = `-- name: CreateAlgorithm :exec
WITH processor_id AS (
  SELECT id FROM processor p
  WHERE p.name = $4 
  AND p.runtime = $5
),
window_type_id AS (
  SELECT id FROM window_type w
  WHERE w.name = $6 
  AND w.version = $7
)
INSERT INTO algorithm (
  name,
  version,
  processor_id,
  window_type_id,
  result_type
) VALUES (
  $1,
  $2,
  (SELECT id FROM processor_id),
  (SELECT id FROM window_type_id),
  $3
) ON CONFLICT DO NOTHING
`

type CreateAlgorithmParams struct {
	Name              string
	Version           string
	ResultType        ResultType
	ProcessorName     string
	ProcessorRuntime  string
	WindowTypeName    string
	WindowTypeVersion string
}

func (q *Queries) CreateAlgorithm(ctx context.Context, arg CreateAlgorithmParams) error {
	_, err := q.db.Exec(ctx, createAlgorithm,
		arg.Name,
		arg.Version,
		arg.ResultType,
		arg.ProcessorName,
		arg.ProcessorRuntime,
		arg.WindowTypeName,
		arg.WindowTypeVersion,
	)
	return err
}

const createAlgorithmDependency = `-- name: CreateAlgorithmDependency :exec
WITH from_algo AS (
  SELECT a.id, a.window_type_id, a.processor_id FROM algorithm a
  JOIN processor p ON a.processor_id = p.id
  WHERE a.name = $1
  AND a.version = $2
  AND p.name = $3
  AND p.runtime = $4
),
to_algo AS (
  SELECT a.id, a.window_type_id, a.processor_id FROM algorithm a
  JOIN processor p ON a.processor_id = p.id
  WHERE a.name = $5
  AND a.version = $6
  AND p.name = $7
  AND p.runtime = $8
)
INSERT INTO algorithm_dependency (
  from_algorithm_id,
  to_algorithm_id,
  from_window_type_id,
  to_window_type_id,
  from_processor_id,
  to_processor_id
) VALUES (
  (SELECT id FROM from_algo LIMIT 1),
  (SELECT id FROM to_algo LIMIT 1),
  (SELECT window_type_id FROM from_algo LIMIT 1),
  (SELECT window_type_id FROM to_algo LIMIT 1),
  (SELECT processor_id FROM from_algo LIMIT 1),
  (SELECT processor_id FROM to_algo LIMIT 1)
) ON CONFLICT (from_algorithm_id, to_algorithm_id) DO UPDATE
  SET
    from_window_type_id = excluded.from_window_type_id,
    to_window_type_id = excluded.to_window_type_id,
    from_processor_id = excluded.from_processor_id,
    to_processor_id = excluded.to_processor_id
`

type CreateAlgorithmDependencyParams struct {
	FromAlgorithmName    string
	FromAlgorithmVersion string
	FromProcessorName    string
	FromProcessorRuntime string
	ToAlgorithmName      string
	ToAlgorithmVersion   string
	ToProcessorName      string
	ToProcessorRuntime   string
}

func (q *Queries) CreateAlgorithmDependency(ctx context.Context, arg CreateAlgorithmDependencyParams) error {
	_, err := q.db.Exec(ctx, createAlgorithmDependency,
		arg.FromAlgorithmName,
		arg.FromAlgorithmVersion,
		arg.FromProcessorName,
		arg.FromProcessorRuntime,
		arg.ToAlgorithmName,
		arg.ToAlgorithmVersion,
		arg.ToProcessorName,
		arg.ToProcessorRuntime,
	)
	return err
}

const createAnnotation = `-- name: CreateAnnotation :one
INSERT INTO annotations (time_from, time_to, description, metadata) 
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateAnnotationParams struct {
	TimeFrom    pgtype.Timestamp
	TimeTo      pgtype.Timestamp
	Description pgtype.Text
	Metadata    []byte
}

// -------------------- Annotation operations ----------------------
func (q *Queries) CreateAnnotation(ctx context.Context, arg CreateAnnotationParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAnnotation,
		arg.TimeFrom,
		arg.TimeTo,
		arg.Description,
		arg.Metadata,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createMetadataField = `-- name: CreateMetadataField :one
INSERT INTO metadata_fields (
  name,
  description
) VALUES (
  $1,
  $2
) ON CONFLICT (name) DO UPDATE
SET
  name = EXCLUDED.name,
  description = EXCLUDED.description
RETURNING id
`

type CreateMetadataFieldParams struct {
	Name        string
	Description string
}

func (q *Queries) CreateMetadataField(ctx context.Context, arg CreateMetadataFieldParams) (int64, error) {
	row := q.db.QueryRow(ctx, createMetadataField, arg.Name, arg.Description)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createProcessorAndPurgeAlgos = `-- name: CreateProcessorAndPurgeAlgos :exec
INSERT INTO processor (
  name,
  runtime,
  connection_string
) VALUES (
  $1,
  $2,
  $3
) ON CONFLICT (name, runtime) DO UPDATE 
SET 
  name = EXCLUDED.name,
  runtime = EXCLUDED.runtime,
  connection_string = EXCLUDED.connection_string
RETURNING id
`

type CreateProcessorAndPurgeAlgosParams struct {
	Name             string
	Runtime          string
	ConnectionString string
}

// -------------------- Core Operations ----------------------
func (q *Queries) CreateProcessorAndPurgeAlgos(ctx context.Context, arg CreateProcessorAndPurgeAlgosParams) error {
	_, err := q.db.Exec(ctx, createProcessorAndPurgeAlgos, arg.Name, arg.Runtime, arg.ConnectionString)
	return err
}

const createResult = `-- name: CreateResult :one
INSERT INTO results (
  windows_id,
  window_type_id, 
  algorithm_id, 
  result_value,
  result_array,
  result_json
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
) RETURNING id
`

type CreateResultParams struct {
	WindowsID    pgtype.Int8
	WindowTypeID pgtype.Int8
	AlgorithmID  pgtype.Int8
	ResultValue  pgtype.Float8
	ResultArray  []float64
	ResultJson   []byte
}

func (q *Queries) CreateResult(ctx context.Context, arg CreateResultParams) (int64, error) {
	row := q.db.QueryRow(ctx, createResult,
		arg.WindowsID,
		arg.WindowTypeID,
		arg.AlgorithmID,
		arg.ResultValue,
		arg.ResultArray,
		arg.ResultJson,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createWindowType = `-- name: CreateWindowType :one
INSERT INTO window_type (
  name,
  version,
  description
) VALUES (
  $1,
  $2,
  $3
) ON CONFLICT (name, version) DO UPDATE
SET
  name = EXCLUDED.name,
  version = EXCLUDED.version,
  description = EXCLUDED.description
RETURNING id
`

type CreateWindowTypeParams struct {
	Name        string
	Version     string
	Description string
}

func (q *Queries) CreateWindowType(ctx context.Context, arg CreateWindowTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, createWindowType, arg.Name, arg.Version, arg.Description)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createWindowTypeMetadataFieldBridge = `-- name: CreateWindowTypeMetadataFieldBridge :exec
INSERT INTO metadata_fields_references (
  window_type_id,
  metadata_fields_id
) VALUES (
  $1,
  $2
)
`

type CreateWindowTypeMetadataFieldBridgeParams struct {
	WindowTypeID     int64
	MetadataFieldsID int64
}

func (q *Queries) CreateWindowTypeMetadataFieldBridge(ctx context.Context, arg CreateWindowTypeMetadataFieldBridgeParams) error {
	_, err := q.db.Exec(ctx, createWindowTypeMetadataFieldBridge, arg.WindowTypeID, arg.MetadataFieldsID)
	return err
}

const linkAnnotationToAlgorithm = `-- name: LinkAnnotationToAlgorithm :exec
WITH algorithm_id AS (
  SELECT
    id
  FROM algorithm
  WHERE
    name = $2
    AND version = $3
)
INSERT INTO 
  annotation_algorithms (annotation_id, algorithm_id)
VALUES ($1, (SELECT id FROM algorithm_id))
`

type LinkAnnotationToAlgorithmParams struct {
	AnnotationID     int64
	AlgorithmName    string
	AlgorithmVersion string
}

func (q *Queries) LinkAnnotationToAlgorithm(ctx context.Context, arg LinkAnnotationToAlgorithmParams) error {
	_, err := q.db.Exec(ctx, linkAnnotationToAlgorithm, arg.AnnotationID, arg.AlgorithmName, arg.AlgorithmVersion)
	return err
}

const linkAnnotationToWindowType = `-- name: LinkAnnotationToWindowType :exec
WITH window_type_id AS (
  SELECT
    id
  FROM window_type
  WHERE
    name = $2
    AND version = $3
)
INSERT INTO annotation_window_types (annotation_id, window_type_id)
VALUES ($1, (SELECT id FROM window_type_id))
`

type LinkAnnotationToWindowTypeParams struct {
	AnnotationID  int64
	WindowName    string
	WindowVersion string
}

func (q *Queries) LinkAnnotationToWindowType(ctx context.Context, arg LinkAnnotationToWindowTypeParams) error {
	_, err := q.db.Exec(ctx, linkAnnotationToWindowType, arg.AnnotationID, arg.WindowName, arg.WindowVersion)
	return err
}

const readAlgorithmExecutionPaths = `-- name: ReadAlgorithmExecutionPaths :many
SELECT aep.final_algo_id, aep.num_dependencies, aep.algo_id_path, aep.window_type_id_path, aep.proc_id_path FROM algorithm_execution_paths aep WHERE aep.window_type_id_path ~ ('*.' || $1::TEXT || '.*')::lquery
`

func (q *Queries) ReadAlgorithmExecutionPaths(ctx context.Context, windowTypeID string) ([]AlgorithmExecutionPath, error) {
	rows, err := q.db.Query(ctx, readAlgorithmExecutionPaths, windowTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlgorithmExecutionPath
	for rows.Next() {
		var i AlgorithmExecutionPath
		if err := rows.Scan(
			&i.FinalAlgoID,
			&i.NumDependencies,
			&i.AlgoIDPath,
			&i.WindowTypeIDPath,
			&i.ProcIDPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAlgorithmExecutionPathsForAlgo = `-- name: ReadAlgorithmExecutionPathsForAlgo :many
SELECT aep.final_algo_id, aep.num_dependencies, aep.algo_id_path, aep.window_type_id_path, aep.proc_id_path FROM algorithm_execution_paths aep WHERE aep.final_algo_id=$1
`

func (q *Queries) ReadAlgorithmExecutionPathsForAlgo(ctx context.Context, algoID int64) ([]AlgorithmExecutionPath, error) {
	rows, err := q.db.Query(ctx, readAlgorithmExecutionPathsForAlgo, algoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlgorithmExecutionPath
	for rows.Next() {
		var i AlgorithmExecutionPath
		if err := rows.Scan(
			&i.FinalAlgoID,
			&i.NumDependencies,
			&i.AlgoIDPath,
			&i.WindowTypeIDPath,
			&i.ProcIDPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAlgorithmId = `-- name: ReadAlgorithmId :one
WITH processor_id AS (
  SELECT p.id FROM processor p
  WHERE p.name = $3
  AND p.runtime = $4
)
SELECT a.id FROM algorithm a
WHERE a.name = $1
AND a.version = $2
AND a.processor_id = (SELECT id from processor_id)
`

type ReadAlgorithmIdParams struct {
	AlgorithmName    string
	AlgorithmVersion string
	ProcessorName    string
	ProcessorRuntime string
}

func (q *Queries) ReadAlgorithmId(ctx context.Context, arg ReadAlgorithmIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, readAlgorithmId,
		arg.AlgorithmName,
		arg.AlgorithmVersion,
		arg.ProcessorName,
		arg.ProcessorRuntime,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const readAlgorithmJsonField = `-- name: ReadAlgorithmJsonField :many
select w.time_from, w.time_to, (r.result_json::json->>$1) as result from results r
join algorithm a on r.algorithm_id = a.id
join windows w on r.windows_id = w.id
where
	w.time_from  >= $2 and w.time_to <= $3
	and a."name" = $4
	and a."version" = $5
`

type ReadAlgorithmJsonFieldParams struct {
	FieldName        []byte
	TimeFrom         pgtype.Timestamp
	TimeTo           pgtype.Timestamp
	AlgorithmName    string
	AlgorithmVersion string
}

type ReadAlgorithmJsonFieldRow struct {
	TimeFrom pgtype.Timestamp
	TimeTo   pgtype.Timestamp
	Result   interface{}
}

func (q *Queries) ReadAlgorithmJsonField(ctx context.Context, arg ReadAlgorithmJsonFieldParams) ([]ReadAlgorithmJsonFieldRow, error) {
	rows, err := q.db.Query(ctx, readAlgorithmJsonField,
		arg.FieldName,
		arg.TimeFrom,
		arg.TimeTo,
		arg.AlgorithmName,
		arg.AlgorithmVersion,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadAlgorithmJsonFieldRow
	for rows.Next() {
		var i ReadAlgorithmJsonFieldRow
		if err := rows.Scan(&i.TimeFrom, &i.TimeTo, &i.Result); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAlgorithms = `-- name: ReadAlgorithms :many
SELECT
  a.id,
  a.name,
  a.version,
  a.created,
  a.result_type,
  w.name as window_name, 
  w.version as window_version,
  p.name as processor_name, 
  p.runtime as processor_runtime
FROM algorithm a
  JOIN window_type w ON a.window_type_id = w.id
  JOIN processor p ON a.processor_id = p.id
ORDER BY a.processor_id, a.created DESC
`

type ReadAlgorithmsRow struct {
	ID               int64
	Name             string
	Version          string
	Created          pgtype.Timestamp
	ResultType       ResultType
	WindowName       string
	WindowVersion    string
	ProcessorName    string
	ProcessorRuntime string
}

func (q *Queries) ReadAlgorithms(ctx context.Context) ([]ReadAlgorithmsRow, error) {
	rows, err := q.db.Query(ctx, readAlgorithms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadAlgorithmsRow
	for rows.Next() {
		var i ReadAlgorithmsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Created,
			&i.ResultType,
			&i.WindowName,
			&i.WindowVersion,
			&i.ProcessorName,
			&i.ProcessorRuntime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAlgorithmsForWindow = `-- name: ReadAlgorithmsForWindow :many
SELECT a.id, a.name, a.version, a.processor_id, a.window_type_id, a.result_type, a.created FROM algorithm a
JOIN window_type wt ON a.window_type_id = wt.id
WHERE wt.name = $1 
AND wt.version = $2
`

type ReadAlgorithmsForWindowParams struct {
	WindowTypeName    string
	WindowTypeVersion string
}

func (q *Queries) ReadAlgorithmsForWindow(ctx context.Context, arg ReadAlgorithmsForWindowParams) ([]Algorithm, error) {
	rows, err := q.db.Query(ctx, readAlgorithmsForWindow, arg.WindowTypeName, arg.WindowTypeVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Algorithm
	for rows.Next() {
		var i Algorithm
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.ProcessorID,
			&i.WindowTypeID,
			&i.ResultType,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAllProcessors = `-- name: ReadAllProcessors :many
SELECT 
  id,
  name,
  runtime,
  connection_string,
  created
FROM processor
ORDER BY name, runtime
`

func (q *Queries) ReadAllProcessors(ctx context.Context) ([]Processor, error) {
	rows, err := q.db.Query(ctx, readAllProcessors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Processor
	for rows.Next() {
		var i Processor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Runtime,
			&i.ConnectionString,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readDistinctJsonResultFieldsForAlgorithm = `-- name: ReadDistinctJsonResultFieldsForAlgorithm :many
select distinct jsonb_object_keys(r.result_json) as field_names from results r
join algorithm a on r.algorithm_id = a.id
join windows w on r.windows_id = w.id
where
	w.time_from  >= $1 and w.time_to <= $2
	and a."name" = $3
	and a."version" = $4
`

type ReadDistinctJsonResultFieldsForAlgorithmParams struct {
	TimeFrom         pgtype.Timestamp
	TimeTo           pgtype.Timestamp
	AlgorithmName    string
	AlgorithmVersion string
}

func (q *Queries) ReadDistinctJsonResultFieldsForAlgorithm(ctx context.Context, arg ReadDistinctJsonResultFieldsForAlgorithmParams) ([]string, error) {
	rows, err := q.db.Query(ctx, readDistinctJsonResultFieldsForAlgorithm,
		arg.TimeFrom,
		arg.TimeTo,
		arg.AlgorithmName,
		arg.AlgorithmVersion,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var field_names string
		if err := rows.Scan(&field_names); err != nil {
			return nil, err
		}
		items = append(items, field_names)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readDistinctWindowMetadata = `-- name: ReadDistinctWindowMetadata :many
SELECT DISTINCT w.metadata FROM windows w
JOIN window_type wt ON w.window_type_id = wt.id 
WHERE
  w.time_from  >= $1
  AND w.time_to <= $2
  AND wt.name = $3
  AND wt.version = $4
`

type ReadDistinctWindowMetadataParams struct {
	TimeFrom          pgtype.Timestamp
	TimeTo            pgtype.Timestamp
	WindowTypeName    string
	WindowTypeVersion string
}

func (q *Queries) ReadDistinctWindowMetadata(ctx context.Context, arg ReadDistinctWindowMetadataParams) ([][]byte, error) {
	rows, err := q.db.Query(ctx, readDistinctWindowMetadata,
		arg.TimeFrom,
		arg.TimeTo,
		arg.WindowTypeName,
		arg.WindowTypeVersion,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var metadata []byte
		if err := rows.Scan(&metadata); err != nil {
			return nil, err
		}
		items = append(items, metadata)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readFromAlgorithmDependencies = `-- name: ReadFromAlgorithmDependencies :many
WITH from_algo AS (
  SELECT a.id, a.window_type_id, a.processor_id FROM algorithm a
  JOIN processor p ON a.processor_id = p.id
  WHERE a.name = $1
  AND a.version = $2
  AND p.name = $3
  AND p.runtime = $4
)
SELECT ad.id, ad.from_algorithm_id, ad.to_algorithm_id, ad.from_window_type_id, ad.to_window_type_id, ad.from_processor_id, ad.to_processor_id, ad.created FROM algorithm_dependency ad WHERE ad.from_algorithm_id = from_algo.id
`

type ReadFromAlgorithmDependenciesParams struct {
	FromAlgorithmName    string
	FromAlgorithmVersion string
	FromProcessorName    string
	FromProcessorRuntime string
}

func (q *Queries) ReadFromAlgorithmDependencies(ctx context.Context, arg ReadFromAlgorithmDependenciesParams) ([]AlgorithmDependency, error) {
	rows, err := q.db.Query(ctx, readFromAlgorithmDependencies,
		arg.FromAlgorithmName,
		arg.FromAlgorithmVersion,
		arg.FromProcessorName,
		arg.FromProcessorRuntime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlgorithmDependency
	for rows.Next() {
		var i AlgorithmDependency
		if err := rows.Scan(
			&i.ID,
			&i.FromAlgorithmID,
			&i.ToAlgorithmID,
			&i.FromWindowTypeID,
			&i.ToWindowTypeID,
			&i.FromProcessorID,
			&i.ToProcessorID,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readMetadataFieldsByWindowType = `-- name: ReadMetadataFieldsByWindowType :many
SELECT 
    metadata_field_id,
    metadata_field_name,
    metadata_field_description
FROM window_type_metadata_fields
WHERE window_type_name = $1
  AND window_type_version = $2
ORDER BY metadata_field_name
`

type ReadMetadataFieldsByWindowTypeParams struct {
	WindowTypeName    string
	WindowTypeVersion string
}

type ReadMetadataFieldsByWindowTypeRow struct {
	MetadataFieldID          int64
	MetadataFieldName        string
	MetadataFieldDescription string
}

func (q *Queries) ReadMetadataFieldsByWindowType(ctx context.Context, arg ReadMetadataFieldsByWindowTypeParams) ([]ReadMetadataFieldsByWindowTypeRow, error) {
	rows, err := q.db.Query(ctx, readMetadataFieldsByWindowType, arg.WindowTypeName, arg.WindowTypeVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadMetadataFieldsByWindowTypeRow
	for rows.Next() {
		var i ReadMetadataFieldsByWindowTypeRow
		if err := rows.Scan(&i.MetadataFieldID, &i.MetadataFieldName, &i.MetadataFieldDescription); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readProcessors = `-- name: ReadProcessors :many
SELECT
  id,
  name, 
  runtime, 
  created
FROM processor
ORDER BY created DESC
`

type ReadProcessorsRow struct {
	ID      int64
	Name    string
	Runtime string
	Created pgtype.Timestamp
}

func (q *Queries) ReadProcessors(ctx context.Context) ([]ReadProcessorsRow, error) {
	rows, err := q.db.Query(ctx, readProcessors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadProcessorsRow
	for rows.Next() {
		var i ReadProcessorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Runtime,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readProcessorsByIDs = `-- name: ReadProcessorsByIDs :many
SELECT 
  id,
  name,
  runtime,
  connection_string,
  created
FROM processor
WHERE id = ANY($1::bigint[])
ORDER BY name, runtime
`

func (q *Queries) ReadProcessorsByIDs(ctx context.Context, processorIds []int64) ([]Processor, error) {
	rows, err := q.db.Query(ctx, readProcessorsByIDs, processorIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Processor
	for rows.Next() {
		var i Processor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Runtime,
			&i.ConnectionString,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readResultsForAlgorithm = `-- name: ReadResultsForAlgorithm :many
select
  w.time_from,
  w.time_to,
  r.result_value,
  r.result_array,
  r.result_json
from results r
join algorithm a on r.algorithm_id = a.id
join windows w on r.windows_id = w.id
where
	w.time_from  >= $1 and w.time_to <= $2
	and a."name" = $3
	and a."version" = $4
ORDER BY w.time_from, w.time_to ASC
`

type ReadResultsForAlgorithmParams struct {
	TimeFrom         pgtype.Timestamp
	TimeTo           pgtype.Timestamp
	AlgorithmName    string
	AlgorithmVersion string
}

type ReadResultsForAlgorithmRow struct {
	TimeFrom    pgtype.Timestamp
	TimeTo      pgtype.Timestamp
	ResultValue pgtype.Float8
	ResultArray []float64
	ResultJson  []byte
}

func (q *Queries) ReadResultsForAlgorithm(ctx context.Context, arg ReadResultsForAlgorithmParams) ([]ReadResultsForAlgorithmRow, error) {
	rows, err := q.db.Query(ctx, readResultsForAlgorithm,
		arg.TimeFrom,
		arg.TimeTo,
		arg.AlgorithmName,
		arg.AlgorithmVersion,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadResultsForAlgorithmRow
	for rows.Next() {
		var i ReadResultsForAlgorithmRow
		if err := rows.Scan(
			&i.TimeFrom,
			&i.TimeTo,
			&i.ResultValue,
			&i.ResultArray,
			&i.ResultJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readResultsForAlgorithmAndMetadata = `-- name: ReadResultsForAlgorithmAndMetadata :many
WITH algorithmId AS (
  SELECT id FROM algorithm WHERE name = $4 AND version = $5
)
SELECT
  w.time_from,
  w.time_to,
  w.metadata,
  r.result_value,
  r.result_array,
  r.result_json
FROM results r
JOIN windows w ON r.windows_id  = w.id
WHERE
  w.time_from >= $1 AND
  w.time_to <= $2 AND
  w.metadata::jsonb @> $3::jsonb AND
  r.algorithm_id = (SELECT id FROM algorithmId)
ORDER BY w.time_from, w.time_to ASC
`

type ReadResultsForAlgorithmAndMetadataParams struct {
	TimeFrom         pgtype.Timestamp
	TimeTo           pgtype.Timestamp
	MetadataFilter   []byte
	AlgorithmName    string
	AlgorithmVersion string
}

type ReadResultsForAlgorithmAndMetadataRow struct {
	TimeFrom    pgtype.Timestamp
	TimeTo      pgtype.Timestamp
	Metadata    []byte
	ResultValue pgtype.Float8
	ResultArray []float64
	ResultJson  []byte
}

func (q *Queries) ReadResultsForAlgorithmAndMetadata(ctx context.Context, arg ReadResultsForAlgorithmAndMetadataParams) ([]ReadResultsForAlgorithmAndMetadataRow, error) {
	rows, err := q.db.Query(ctx, readResultsForAlgorithmAndMetadata,
		arg.TimeFrom,
		arg.TimeTo,
		arg.MetadataFilter,
		arg.AlgorithmName,
		arg.AlgorithmVersion,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadResultsForAlgorithmAndMetadataRow
	for rows.Next() {
		var i ReadResultsForAlgorithmAndMetadataRow
		if err := rows.Scan(
			&i.TimeFrom,
			&i.TimeTo,
			&i.Metadata,
			&i.ResultValue,
			&i.ResultArray,
			&i.ResultJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readResultsStats = `-- name: ReadResultsStats :one
SELECT
  COUNT(r.id)
FROM results r
`

func (q *Queries) ReadResultsStats(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, readResultsStats)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const readWindowTypes = `-- name: ReadWindowTypes :many
SELECT
  id, 
  version, 
  name,
  description,
  created
FROM window_type
ORDER BY created DESC
`

type ReadWindowTypesRow struct {
	ID          int64
	Version     string
	Name        string
	Description string
	Created     pgtype.Timestamp
}

// -------------------- Data operations ----------------------
func (q *Queries) ReadWindowTypes(ctx context.Context) ([]ReadWindowTypesRow, error) {
	rows, err := q.db.Query(ctx, readWindowTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadWindowTypesRow
	for rows.Next() {
		var i ReadWindowTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readWindows = `-- name: ReadWindows :many
select
  w.time_from,
  w.time_to,
  w.origin,
  w.metadata,
  wt.name,
  wt.version
from windows w
join window_type wt on w.window_type_id =wt.id
where
	wt."name" = $1 and wt."version" = $2
	and w.time_from  >= $3 and w.time_to <= $4
ORDER BY w.time_from, w.time_to ASC
`

type ReadWindowsParams struct {
	WindowTypeName    string
	WindowTypeVersion string
	TimeFrom          pgtype.Timestamp
	TimeTo            pgtype.Timestamp
}

type ReadWindowsRow struct {
	TimeFrom pgtype.Timestamp
	TimeTo   pgtype.Timestamp
	Origin   string
	Metadata []byte
	Name     string
	Version  string
}

func (q *Queries) ReadWindows(ctx context.Context, arg ReadWindowsParams) ([]ReadWindowsRow, error) {
	rows, err := q.db.Query(ctx, readWindows,
		arg.WindowTypeName,
		arg.WindowTypeVersion,
		arg.TimeFrom,
		arg.TimeTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadWindowsRow
	for rows.Next() {
		var i ReadWindowsRow
		if err := rows.Scan(
			&i.TimeFrom,
			&i.TimeTo,
			&i.Origin,
			&i.Metadata,
			&i.Name,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readWindowsForMetadata = `-- name: ReadWindowsForMetadata :many
select
  w.time_from,
  w.time_to,
  w.origin,
  w.metadata,
  wt.name,
  wt.version
from windows w
join window_type wt on w.window_type_id =wt.id
where
	wt."name" = $1 and wt."version" = $2
	and w.time_from  >= $3 and w.time_to <= $4
	and w.metadata::jsonb @> $5::jsonb
ORDER BY w.time_from, w.time_to ASC
`

type ReadWindowsForMetadataParams struct {
	WindowTypeName    string
	WindowTypeVersion string
	TimeFrom          pgtype.Timestamp
	TimeTo            pgtype.Timestamp
	MetadataFilter    []byte
}

type ReadWindowsForMetadataRow struct {
	TimeFrom pgtype.Timestamp
	TimeTo   pgtype.Timestamp
	Origin   string
	Metadata []byte
	Name     string
	Version  string
}

func (q *Queries) ReadWindowsForMetadata(ctx context.Context, arg ReadWindowsForMetadataParams) ([]ReadWindowsForMetadataRow, error) {
	rows, err := q.db.Query(ctx, readWindowsForMetadata,
		arg.WindowTypeName,
		arg.WindowTypeVersion,
		arg.TimeFrom,
		arg.TimeTo,
		arg.MetadataFilter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadWindowsForMetadataRow
	for rows.Next() {
		var i ReadWindowsForMetadataRow
		if err := rows.Scan(
			&i.TimeFrom,
			&i.TimeTo,
			&i.Origin,
			&i.Metadata,
			&i.Name,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerWindow = `-- name: RegisterWindow :one
WITH window_type_id AS (
  SELECT id FROM window_type 
  WHERE name = $5 
  AND version = $6
)
INSERT INTO windows (
  window_type_id,
  time_from, 
  time_to,
  origin, 
  metadata
) VALUES (
  (SELECT id FROM window_type_id),
  $1,
  $2,
  $3,
  $4
) RETURNING window_type_id, id
`

type RegisterWindowParams struct {
	TimeFrom          pgtype.Timestamp
	TimeTo            pgtype.Timestamp
	Origin            string
	Metadata          []byte
	WindowTypeName    string
	WindowTypeVersion string
}

type RegisterWindowRow struct {
	WindowTypeID int64
	ID           int64
}

func (q *Queries) RegisterWindow(ctx context.Context, arg RegisterWindowParams) (RegisterWindowRow, error) {
	row := q.db.QueryRow(ctx, registerWindow,
		arg.TimeFrom,
		arg.TimeTo,
		arg.Origin,
		arg.Metadata,
		arg.WindowTypeName,
		arg.WindowTypeVersion,
	)
	var i RegisterWindowRow
	err := row.Scan(&i.WindowTypeID, &i.ID)
	return i, err
}
